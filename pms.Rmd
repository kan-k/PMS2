---
title: "Varscreen"
author: "Kan Keeratimahat"
date: "11/03/2024"
output: html_document
---

#11 Mar
Want to test a reconstruction of data for Lambda matrix, using Robust PCA.
I will test on a subset of data, so just for testing, I will use a centre mask that I created in `pms_extension_2.Rmd` in the folder PMS
which is done via
`submask[36:54,47:60,32:45] <- mask_subcor[36:54,47:60,32:45]`
table(submask[submask!=0]) #1613 voxels in total
saved as `'/well/nichols/users/qcv214/PMS/sub_centre_mask'`

I will also used a saved dataset from there with 4xxx subjects. Do not use this in the future
I will subset this to 100
```{r}
library(feather)
sub.dat <- read_feather('/well/nichols/users/qcv214/PMS/sub_dat.feather') #dim = 4263 124859
#Let's subset that to 100
sub.dat.test <- as.matrix(sub.dat[101:200,])
sub.dat <- as.matrix(sub.dat[1:100,])
```


##Get age response
```{r}
part_list<-read.table('/well/nichols/users/qcv214/Placement_2/participant_list.txt', header = FALSE, sep = "", dec = ".") #4529 participants 
part_list$exist_vbm <- file.exists(paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',part_list[,1],'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz'))
#These two are equal
part_use<-part_list[part_list$exist_vbm==1,] #4262 participants left
part_use<-part_use[1:200,] #only take 100

agetab<-read.table(file = '/well/nichols/projects/UKB/SMS/ukb_latest-Age.tsv', sep = '\t', header = TRUE)
age_tab<-as.data.frame(matrix(,nrow = length(part_use$V1),ncol = 2)) #id, age, number of masked voxels
colnames(age_tab)[1:2]<-c('id','age')
age_tab$id<-part_use$V1
for(i in 1:length(part_use$V1)){
  age_tab$age[i]<-agetab$X21003.2.0[agetab$eid_8107==sub(".", "",age_tab$id[i])]
}

age_tab.test <- age_tab[101:200,]
age_tab <- age_tab[1:100,]

```

###Fit with lasso
```{r}
library(glmnet)
set.seed(4)
fit <- cv.glmnet(sub.dat,age_tab$age, alpha=1)
coef.lasso <- coef(fit, s="lambda.min")
#Above is super sparse 
sum(coef.lasso!=0) #59 out of 1k... this is very sensitive to runs, some only have 16 selected
coef.selected <- rownames(coef.lasso)[which(coef.lasso!=0)]
```

####I will fit Ridge to obtain estimated beta
```{r}
set.seed(4)
fit.ridge <- cv.glmnet(sub.dat,age_tab$age, alpha=0)
beta <- coef(fit.ridge)
beta_no_int <- beta[-1,]
rank_beta.ridge <- beta_no_int[order(abs(beta_no_int), decreasing=TRUE)]
#y - xbeta
err <- as.numeric(age_tab$age - cbind(1,sub.dat)%*%beta)
```

### Robust PCA
####Robust PCA is calcualted based on `h` data points with smallest outlyingness measure used to compute cov matrix before pca

```{r}
library(rrcov) #Package for robust PCA
set.seed(4)
pca <- PcaHubert(sub.dat) #it only picks 10 PC ####Note that I need to change kmax to greater than 10
lambda <- pca$loadings[,10] %*% t(pca$loadings[,10]) 
Omeg <- solve(sub.dat%*%lambda%*%t(sub.dat) + (1e-5)*diag(nrow(sub.dat))) #4x4 
pre_beta_pms <- lambda%*%t(sub.dat)%*%Omeg #4 x 75

beta_pms <- beta[2:length(beta)] + pre_beta_pms%*%err
rownames(beta_pms) <- colnames(sub.dat)
#rank the absolute value of beta_pms with corresponding variable names
rank_beta_pms <- beta_pms[order(abs(beta_pms), decreasing=TRUE),]

nomean_beta_pms <- pre_beta_pms%*%err
rownames(nomean_beta_pms) <- colnames(sub.dat)
head(nomean_beta_pms[order(abs(nomean_beta_pms), decreasing=TRUE),],20)
```

###Vanilla PCA
```{r}
set.seed(4)
pca.normal <- prcomp(sub.dat)
#plot the variance explained
plot(pca.normal)
lambda.normal <- pca.normal$rotation[,10] %*% t(pca.normal$rotation[,10])
Omeg <- solve(sub.dat%*%lambda.normal%*%t(sub.dat) + (1e-5)*diag(nrow(sub.dat))) #4x4 
#Construct pre_beta_pms
pre_beta_pms.normal <- lambda.normal%*%t(sub.dat)%*%Omeg #4 x 75

beta_pms.normal <- beta[2:length(beta)] + pre_beta_pms.normal %*%err
rownames(beta_pms.normal) <- colnames(sub.dat)
#rank the absolute value of beta_pms with corresponding variable names
rank_beta_pms.normal <- beta_pms.normal[order(abs(beta_pms.normal), decreasing=TRUE),]

nomean_beta_pms.normal <- pre_beta_pms.normal%*%err
rownames(nomean_beta_pms.normal) <- colnames(sub.dat)
head(nomean_beta_pms.normal[order(abs(nomean_beta_pms.normal), decreasing=TRUE),],20)
```
#Let's look at overlap
```{r}
overlap <- function(rank_normal, rank_robust, k){
  top_k_normal <- names(rank_robust)[1:k]
  top_k <- names(rank_normal)[1:k]
  print(paste("Overlap of top", k, "variables:", length(intersect(top_k_normal, top_k)) ))
}

```
```{r}
for (i in c(10,54,100,200,500)){
  overlap(rank_beta_pms.normal,rank_beta_pms,i)
}
```

```{r}
ranked_nomean_beta_pms.normal <- nomean_beta_pms.normal[order(abs(nomean_beta_pms.normal), decreasing=TRUE),]
ranked_nomean_beta_pms <- nomean_beta_pms[order(abs(nomean_beta_pms), decreasing=TRUE),]
for (i in c(10,100,200)){
  overlap(ranked_nomean_beta_pms.normal,ranked_nomean_beta_pms,i)
}
```

```{r}
sum(coef.selected %in% names(ranked_nomean_beta_pms[1:500]))
```


### sd of data
```{r}
sd(age_tab$age)
```

###Let's do a prediction accuracy check with the same number of selected variables as LASSO by fitting ridge
```{r}
n.var <- length(coef.selected)-1 #minus intercept
yhat <- predict(fit, newx=sub.dat, s="lambda.min")
sqrt(mean((yhat - age_tab$age)^2)) #2.48
yhat.test <- predict(fit, newx=sub.dat.test, s="lambda.min")
sqrt(mean((yhat.test - age_tab.test$age)^2)) #2.48

```
How is lasso so low. ==> keep in mind this is training sample

###Ridge
```{r}
yhat <- predict(fit.ridge, newx=sub.dat, s="lambda.min")
sqrt(mean((yhat - age_tab$age)^2)) #2.48
yhat.test <- predict(fit.ridge, newx=sub.dat.test, s="lambda.min")
sqrt(mean((yhat.test - age_tab.test$age)^2)) #2.48
```
1.816

###Normal pca
```{r}
var.sel<- names(rank_beta_pms.normal[1:n.var])
fit.ridge.pca.normal <- cv.glmnet(sub.dat[,var.sel],age_tab$age, alpha=0)
beta <- coef(fit.ridge.pca.normal)
#y - xbeta
(rmse.normal <- sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat[,var.sel])%*%beta))^2)))
```

```{r}
var.sel<- names(rank_beta_pms.normal[1:500])
fit.ridge.pca.normal <- cv.glmnet(sub.dat[,var.sel],age_tab$age, alpha=0)
beta <- coef(fit.ridge.pca.normal)
#y - xbeta
(rmse.normal <- sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat[,var.sel])%*%beta))^2)))
(rmse.normal.test <- sqrt(mean((as.numeric(age_tab.test$age - cbind(1,sub.dat.test[,var.sel])%*%beta))^2)))

```


###RobPCA
```{r}
var.sel<- names(rank_beta_pms[1:n.var])
fit.ridge.pca <- cv.glmnet(sub.dat[,var.sel],age_tab$age, alpha=0)
beta <- coef(fit.ridge.pca)
#y - xbeta
(rmse <- sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat[,var.sel])%*%beta))^2)))
```
```{r}
var.sel<- names(rank_beta_pms[1:500])
fit.ridge.pca <- cv.glmnet(sub.dat[,var.sel],age_tab$age, alpha=0)
beta <- coef(fit.ridge.pca)
#y - xbeta
(rmse <- sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat[,var.sel])%*%beta))^2)))
(rmse.test <- sqrt(mean((as.numeric(age_tab.test$age - cbind(1,sub.dat.test[,var.sel])%*%beta))^2)))

```


#18 Mar

##To do
1. Change beta prior to 0 (or leave as ridge)
2. Compare this model against truncated ridge
3. Use Lambda to make prediction/fit model as well.
4. Visualise the power of selected pms stats 
5. Do held out performance /


##Assessing the improvement in voxels inclusion

```{r}
long.rmse <- function(ranked_coef, num.vox.vec){
  train <- vector(mode = 'numeric')
  test <- vector(mode = 'numeric')
  for(i in num.vox.vec){
    var.sel<- names(ranked_coef[1:i])
    fit.ridge.pca <- cv.glmnet(sub.dat[,var.sel],age_tab$age, alpha=0)
    beta <- coef(fit.ridge.pca)
    train <- c(train,sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat[,var.sel])%*%beta))^2)))
    test <- c(test,sqrt(mean((as.numeric(age_tab.test$age - cbind(1,sub.dat.test[,var.sel])%*%beta))^2)))
  }
  out <- list()
  out$train <- train
  out$test <- test
  return(out)
}
```

```{r}
num.vox.vec <- (1:100)*10

res.ropca <- long.rmse(rank_beta_pms, num.vox.vec)
res.pca <- long.rmse(rank_beta_pms.normal, num.vox.vec)
res.ridge <- long.rmse(rank_beta.ridge, num.vox.vec)

```

##Plot bbs loss
```{r}
library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.ropca$train,res.pca$train,res.ridge$train))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,5) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```

```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.ropca$test,res.pca$test,res.ridge$test))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(5.5,6.5) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

##Do selection with prior mu = 0
```{r}
#Robust PCA
set.seed(4)
pca <- PcaHubert(sub.dat) #it only picks 10 PC ####Note that I need to change kmax to greater than 10
lambda <- pca$loadings[,10] %*% t(pca$loadings[,10]) 
Omeg <- solve(sub.dat%*%lambda%*%t(sub.dat) + (1e-5)*diag(nrow(sub.dat))) #4x4 
pre_beta_pms <- lambda%*%t(sub.dat)%*%Omeg #4 x 75
beta_pms <- pre_beta_pms%*%age_tab$age
rownames(beta_pms) <- colnames(sub.dat)
rank_beta_pms <- beta_pms[order(abs(beta_pms), decreasing=TRUE),]


#PCA 
set.seed(4)
pca.normal <- prcomp(sub.dat)
lambda.normal <- pca.normal$rotation[,10] %*% t(pca.normal$rotation[,10])
Omeg <- solve(sub.dat%*%lambda.normal%*%t(sub.dat) + (1e-5)*diag(nrow(sub.dat))) #4x4 
pre_beta_pms.normal <- lambda.normal%*%t(sub.dat)%*%Omeg #4 x 75
beta_pms.normal <- pre_beta_pms.normal %*%age_tab$age
rownames(beta_pms.normal) <- colnames(sub.dat)
rank_beta_pms.normal <- beta_pms.normal[order(abs(beta_pms.normal), decreasing=TRUE),]
plot(cumsum(pca.normal$sdev^2)/sum(pca.normal$sdev^2), type = 'b')

```
This cumulative plot shows



```{r}
num.vox.vec <- (1:100)*10

res.ropca <- long.rmse(rank_beta_pms, num.vox.vec)
res.pca <- long.rmse(rank_beta_pms.normal, num.vox.vec)
res.ridge <- long.rmse(rank_beta.ridge, num.vox.vec)

```
```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.ropca$train,res.pca$train,res.ridge$train))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,8) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```

```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.ropca$test,res.pca$test,res.ridge$test))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(5.5,8) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

The ridge result isn't adding up with the previous one. In the previous one, ridge had so much better training rmse than this. 

##Do predictions with Lambda incorporated
I believe this is just doing PMS with rows deleted. Actually lambda is p x p.
I think I will keep the same lambda structure but assign 0 to X instead.

##Create a function to calculate beta pms with zero-ed row of X
```{r}
long.rmse.with.lambda <- function(ranked_coef, num.vox.vec, lambda){
  train <- vector(mode = 'numeric')
  test <- vector(mode = 'numeric')
  for(i in num.vox.vec){
    var.sel<- names(ranked_coef[1:i])
    sub.dat.sub <- sub.dat
    sub.dat.test.sub <- sub.dat.test
    
    mask.out <- setdiff(colnames(sub.dat),var.sel)
    sub.dat.sub[,mask.out] <- 0
    sub.dat.test.sub[,mask.out] <- 0
    
    Omeg <- solve(sub.dat.sub%*%lambda%*%t(sub.dat.sub) + (1e-5)*diag(nrow(sub.dat.sub)))
    beta_pms <- lambda%*%t(sub.dat.sub)%*%Omeg%*%age_tab$age
    intercept <- mean(age_tab$age) - colMeans(sub.dat.sub)%*%beta_pms 
    
    beta <- c(intercept,beta_pms)
    train <- c(train,sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat.sub)%*%beta))^2)))
    test <- c(test,sqrt(mean((as.numeric(age_tab.test$age - cbind(1,sub.dat.test.sub)%*%beta))^2)))
  }
  out <- list()
  out$train <- train
  out$test <- test
  return(out)
}
```

```{r}
num.vox.vec <- (1:100)*10

res.lambda.ropca <- long.rmse.with.lambda(rank_beta_pms, num.vox.vec,lambda)
res.lambda.pca <- long.rmse.with.lambda(rank_beta_pms.normal, num.vox.vec,lambda.normal)

```

```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.lambda.ropca$train,res.lambda.pca$train,res.ridge$train))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,30) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```

```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.lambda.ropca$test,res.lambda.pca$test,res.ridge$test))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(5.5,30) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

#21 March

Look at variance explained
##Do selection with prior mu = 0
```{r}
#Robust PCA
set.seed(4)
pca <- PcaHubert(sub.dat,kmax=100) #it only picks 10 PC ####Note that I need to change kmax to greater than 10
lambda <- pca$loadings[,36] %*% t(pca$loadings[,36]) 
Omeg <- solve(sub.dat%*%lambda%*%t(sub.dat) + (1e-5)*diag(nrow(sub.dat))) #4x4 
pre_beta_pms <- lambda%*%t(sub.dat)%*%Omeg #4 x 75
beta_pms <- pre_beta_pms%*%age_tab$age
rownames(beta_pms) <- colnames(sub.dat)
rank_beta_pms <- beta_pms[order(abs(beta_pms), decreasing=TRUE),]
pca.sum <- summary(pca)
```
Robust pca only allowed 53 PCs.... and variance explaied is 100%
Let's pick PCs such that it takes at least 90% of variance, which is 36 PCs


```{r}
#PCA 
set.seed(4)
pca.normal <- prcomp(sub.dat)
lambda.normal <- pca.normal$rotation[,72] %*% t(pca.normal$rotation[,72])
Omeg <- solve(sub.dat%*%lambda.normal%*%t(sub.dat) + (1e-5)*diag(nrow(sub.dat))) #4x4 
pre_beta_pms.normal <- lambda.normal%*%t(sub.dat)%*%Omeg #4 x 75
beta_pms.normal <- pre_beta_pms.normal %*%age_tab$age
rownames(beta_pms.normal) <- colnames(sub.dat)
rank_beta_pms.normal <- beta_pms.normal[order(abs(beta_pms.normal), decreasing=TRUE),]
plot(cumsum(pca.normal$sdev^2)/sum(pca.normal$sdev^2), type = 'b')
min(which(cumsum(pca.normal$sdev^2)/sum(pca.normal$sdev^2) > 0.9)) #72
```
This PCA cumulative plot shows that we need n = 99 or 100, or something way larger than 10.
Take 72 PCs then it explains 90% of variance explained

```{r}
num.vox.vec <- (1:100)*10

res.ropca <- long.rmse(rank_beta_pms, num.vox.vec)
res.pca <- long.rmse(rank_beta_pms.normal, num.vox.vec)
res.ridge <- long.rmse(rank_beta.ridge, num.vox.vec)

```
```{r}
library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.ropca$train,res.pca$train,res.ridge$train))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,8) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```

```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.ropca$test,res.pca$test,res.ridge$test))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(5.5,8) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

##With lambda prediction
```{r}
num.vox.vec <- (1:100)*10

res.lambda.ropca <- long.rmse.with.lambda(rank_beta_pms, num.vox.vec,lambda)
res.lambda.pca <- long.rmse.with.lambda(rank_beta_pms.normal, num.vox.vec,lambda.normal)

```

```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.lambda.ropca$train,res.lambda.pca$train,res.ridge$train))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,30) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```
```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.lambda.ropca$test,res.lambda.pca$test,res.ridge$test))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(5.5,30) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```


#25 Mar

I need to perhaps scale this to larger images.

Before going into full images, lets scale it up 10 times?

##Get the sub Mask
```{r}
mask_subcor<-oro.nifti::readNIfTI('/well/nichols/users/qcv214/PMS/mask_without_WM_and_stem_thrsholded.nii.gz')

submask <-array(0,dim=dim(mask_subcor))
submask[26:64,37:70,22:55] <- mask_subcor[26:64,37:70,22:55] 
table(submask[submask!=0]) #1613 voxels in total
length(submask[submask!=0]) #15,847 voxels

writeNIfTI(submask,'/well/nichols/users/qcv214/pms2/sub150_centre_mask') #/well/nichols/users/qcv214/pms2

```

##Get age response
```{r}
part_list<-read.table('/well/nichols/users/qcv214/Placement_2/participant_list.txt', header = FALSE, sep = "", dec = ".") #4529 participants
part_list$exist_vbm <- file.exists(paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',part_list[,1],'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz'))
#These two are equal
part_use<-part_list[part_list$exist_vbm==1,] #4262 participants left
part_use<-part_use[1:200,] #only take 100

agetab<-read.table(file = '/well/nichols/projects/UKB/SMS/ukb_latest-Age.tsv', sep = '\t', header = TRUE)
age_tab<-as.data.frame(matrix(,nrow = length(part_use$V1),ncol = 2)) #id, age, number of masked voxels
colnames(age_tab)[1:2]<-c('id','age')
age_tab$id<-part_use$V1
for(i in 1:length(part_use$V1)){
  age_tab$age[i]<-agetab$X21003.2.0[agetab$eid_8107==sub(".", "",age_tab$id[i])]
}
age_tab.test <- age_tab[101:200,]
age_tab <- age_tab[1:100,]
```

##Get data 
```{r}
list_of_all_images<-paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',age_tab$id,'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz')
sub.dat <- as.matrix(fast_read_imgs_mask(list_of_all_images,'/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
colnames(sub.dat) <- as.character(1:ncol(sub.dat))
list_of_all_images<-paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',age_tab.test$id,'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz')
sub.dat.test <- as.matrix(fast_read_imgs_mask(list_of_all_images,'/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
colnames(sub.dat.test) <- colnames(sub.dat)
```

## PMS
Look at variance explained
###Do selection with prior mu = 0
Ridge
```{r}
set.seed(4)
fit.ridge <- cv.glmnet(sub.dat,age_tab$age, alpha=0)
beta <- coef(fit.ridge)
beta_no_int <- beta[-1,]
rank_beta.ridge <- beta_no_int[order(abs(beta_no_int), decreasing=TRUE)]
```

```{r}
library(rrcov) #Package for robust PCA
#Robust PCA
set.seed(4)
pca <- PcaHubert(sub.dat,kmax=100) #it only picks 10 PC ####Note that I need to change kmax to greater than 10
#summary(pca) #look at the first PC that had cumulative variance of 90%
#lambda <- pca$loadings[,54] %*% t(pca$loadings[,54]) 
lambda <- pca$loadings %*% t(pca$loadings) 
Omeg <- solve(sub.dat%*%lambda%*%t(sub.dat) + (1e-5)*diag(nrow(sub.dat))) #4x4 
pre_beta_pms <- lambda%*%t(sub.dat)%*%Omeg #4 x 75
beta_pms <- pre_beta_pms%*%age_tab$age
rownames(beta_pms) <- colnames(sub.dat)
rank_beta_pms <- beta_pms[order(abs(beta_pms), decreasing=TRUE),]
pca.sum <- summary(pca)
```
Robust pca only allowed 53 PCs.... and variance explaied is 100%
Let's pick PCs such that it takes at least 90% of variance, which is 36 PCs


```{r}
#PCA 
set.seed(4)
pca.normal <- prcomp(sub.dat)
ind.touse <- min(which(cumsum(pca.normal$sdev^2)/sum(pca.normal$sdev^2) > 0.9)) #72
#lambda.normal <- pca.normal$rotation[,ind.touse] %*% t(pca.normal$rotation[,ind.touse])
lambda.normal <- pca.normal$rotation%*% t(pca.normal$rotation)
Omeg <- solve(sub.dat%*%lambda.normal%*%t(sub.dat) + (1e-5)*diag(nrow(sub.dat))) #4x4 
pre_beta_pms.normal <- lambda.normal%*%t(sub.dat)%*%Omeg #4 x 75
beta_pms.normal <- pre_beta_pms.normal %*%age_tab$age
rownames(beta_pms.normal) <- colnames(sub.dat)
rank_beta_pms.normal <- beta_pms.normal[order(abs(beta_pms.normal), decreasing=TRUE),]
plot(cumsum(pca.normal$sdev^2)/sum(pca.normal$sdev^2), type = 'b')
min(which(cumsum(pca.normal$sdev^2)/sum(pca.normal$sdev^2) > 0.9)) #81
```
This PCA cumulative plot shows that we need n = 99 or 100, or something way larger than 10.
Take 72 PCs then it explains 90% of variance explained

#calculate rmse without lambda
```{r}
long.rmse <- function(ranked_coef, num.vox.vec){
  train <- vector(mode = 'numeric')
  test <- vector(mode = 'numeric')
  for(i in num.vox.vec){
    var.sel<- names(ranked_coef[1:i])
    fit.ridge.pca <- cv.glmnet(sub.dat[,var.sel],age_tab$age, alpha=0)
    beta <- coef(fit.ridge.pca)
    train <- c(train,sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat[,var.sel])%*%beta))^2)))
    test <- c(test,sqrt(mean((as.numeric(age_tab.test$age - cbind(1,sub.dat.test[,var.sel])%*%beta))^2)))
  }
  out <- list()
  out$train <- train
  out$test <- test
  return(out)
}
```

```{r}
num.vox.vec <- (1:100)*10

res.ropca <- long.rmse(rank_beta_pms, num.vox.vec)
res.pca <- long.rmse(rank_beta_pms.normal, num.vox.vec)
res.ridge <- long.rmse(rank_beta.ridge, num.vox.vec)

```
```{r}
library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.ropca$train,res.pca$train,res.ridge$train))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(1,8) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```

```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.ropca$test,res.pca$test,res.ridge$test))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(5.5,8) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

Note that there is a HUGE difference between using Robust PCA with 90% variance and 100% variance, although the difference is (54 vs 66 PCs)


##With lambda prediction

```{r}
long.rmse.with.lambda <- function(ranked_coef, num.vox.vec, lambda){
  train <- vector(mode = 'numeric')
  test <- vector(mode = 'numeric')
  for(i in num.vox.vec){
    var.sel<- names(ranked_coef[1:i])
    sub.dat.sub <- sub.dat
    sub.dat.test.sub <- sub.dat.test
    
    mask.out <- setdiff(colnames(sub.dat),var.sel)
    sub.dat.sub[,mask.out] <- 0
    sub.dat.test.sub[,mask.out] <- 0
    
    Omeg <- solve(sub.dat.sub%*%lambda%*%t(sub.dat.sub) + (1e-5)*diag(nrow(sub.dat.sub)))
    beta_pms <- lambda%*%t(sub.dat.sub)%*%Omeg%*%age_tab$age
    intercept <- mean(age_tab$age) - colMeans(sub.dat.sub)%*%beta_pms 
    
    beta <- c(intercept,beta_pms)
    train <- c(train,sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat.sub)%*%beta))^2)))
    test <- c(test,sqrt(mean((as.numeric(age_tab.test$age - cbind(1,sub.dat.test.sub)%*%beta))^2)))
  }
  out <- list()
  out$train <- train
  out$test <- test
  return(out)
}
```

```{r}
num.vox.vec <- (1:100)*10

res.lambda.ropca <- long.rmse.with.lambda(rank_beta_pms, num.vox.vec,lambda)
res.lambda.pca <- long.rmse.with.lambda(rank_beta_pms.normal, num.vox.vec,lambda.normal)

```

```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.lambda.ropca$train,res.lambda.pca$train,res.ridge$train))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(0,20) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```
```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.lambda.ropca$test,res.lambda.pca$test,res.ridge$test))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(5.5,15) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```




#26 Mar
Let's map back the brain images
```{r}
#ROBPCA
  #Full ROBPCA
  mask.temp <-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz')
  mask.temp[mask.temp!=0] <- abs(c(beta_pms))
  mask.temp@datatype = 16
  mask.temp@bitpix = 32
  writeNIfTI(mask.temp,paste0('/well/nichols/users/qcv214/pms2/viz/sub150_robpca_pms'))

  #1k ROB PCA
  mask.temp <-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz')
  thres.ind <- as.numeric(names(rank_beta_pms[1:1000]))
  beta_pms.temp <- abs(c(beta_pms))
  beta_pms.temp[-thres.ind] <- -1
  mask.temp[mask.temp!=0] <- beta_pms.temp
  mask.temp@datatype = 16
  mask.temp@bitpix = 32
  writeNIfTI(mask.temp,paste0('/well/nichols/users/qcv214/pms2/viz/sub150_robpca_pms_1000'))
  
#PCA
  #Full PCA
  mask.temp <-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz')
  mask.temp[mask.temp!=0] <- abs(c(beta_pms.normal))
  mask.temp@datatype = 16
  mask.temp@bitpix = 32
  writeNIfTI(mask.temp,paste0('/well/nichols/users/qcv214/pms2/viz/sub150_pca_pms'))

  #1k PCA
  mask.temp <-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz')
  thres.ind <- as.numeric(names(rank_beta_pms.normal[1:1000]))
  beta_pms.temp <- abs(c(beta_pms.normal))
  beta_pms.temp[-thres.ind] <- -1
  mask.temp[mask.temp!=0] <- beta_pms.temp
  mask.temp@datatype = 16
  mask.temp@bitpix = 32
  writeNIfTI(mask.temp,paste0('/well/nichols/users/qcv214/pms2/viz/sub150_pca_pms_1000'))

#Ridge
  #Full Ridge
  mask.temp <-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz')
  mask.temp[mask.temp!=0] <- abs(c(beta_no_int))
  mask.temp@datatype = 16
  mask.temp@bitpix = 32
  writeNIfTI(mask.temp,paste0('/well/nichols/users/qcv214/pms2/viz/sub150_ridge'))

  #1k Ridge
  mask.temp <-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz')
  thres.ind <- as.numeric(names(rank_beta.ridge[1:1000]))
  beta_pms.temp <- abs(c(beta_no_int))
  beta_pms.temp[-thres.ind] <- -1
  mask.temp[mask.temp!=0] <- beta_pms.temp
  mask.temp@datatype = 16
  mask.temp@bitpix = 32
  writeNIfTI(mask.temp,paste0('/well/nichols/users/qcv214/pms2/viz/sub150_ridge_1000'))


```

PCA only detect the very edge of the image somehow. Look at 45,56,21
Ridge is somewhat smooth, centred around the thalamas as usual
ROBPCA is alright, less smooth than ridge somehow.

Let's see if PCA is picking up noises from the edges. by looking at s.d. 
sapply(df, sd)

```{r}
##Standard deviation
#Load data, see `list_of_all_images` the chunk before this.
sub.dat <- as.matrix(fast_read_imgs_mask(list_of_all_images,'/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
colnames(sub.dat) <- as.character(1:ncol(sub.dat))
mask.temp <-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz')
  mask.temp[mask.temp!=0] <- apply(sub.dat, 2, sd)
  mask.temp@datatype = 16
  mask.temp@bitpix = 32
  writeNIfTI(mask.temp,paste0('/well/nichols/users/qcv214/pms2/viz/sub150_sd'))
```

s.d. does not reveal anything funny that would go with the PCA odd behaviour

Assessing the odd behaviour
```{r}
plot(y=abs(c(beta_pms.normal)),x=1:15847, ylab ="Magnitude of PMS statistics",xlab = "Voxel number",main = "PMS: PCA")
plot(y=abs(c(beta_pms)),x=1:15847, ylab ="Magnitude of PMS statistics",xlab = "Voxel number",main = "PMS: Robust PCA")
plot(y=abs(c(beta_no_int)),x=1:15847, ylab ="Magnitude of Ridge",xlab = "Voxel number",main = "Ridge")

```

I will address the index of each voxel and match it with PCA
```{r}
mask.temp <-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz')
mask.temp[mask.temp!=0] <- 1:sum(c(mask.temp!=0))
mask.temp@datatype = 16
mask.temp@bitpix = 32
writeNIfTI(mask.temp,paste0('/well/nichols/users/qcv214/pms2/viz/sub150_centre_mask_index'))
```



#3 apr
##To do 
1. Fix lambda, do subsetting instead of masking out
2. Do cross validation on theta


##Subsetting lambda
```{r}
long.rmse.with.lambda <- function(ranked_coef, num.vox.vec, lambda){
  train <- vector(mode = 'numeric')
  test <- vector(mode = 'numeric')
  for(i in num.vox.vec){
    var.sel<- names(ranked_coef[1:i])
    sub.dat.sub <- sub.dat
    sub.dat.test.sub <- sub.dat.test
    
    mask.out <- as.numeric(setdiff(colnames(sub.dat),var.sel))
    #print(head(mask.out))
    
    sub.dat.sub <- sub.dat.sub[,-c(mask.out)] 
    sub.dat.test.sub<- sub.dat.test.sub[,-c(mask.out)] 
    
    lambda.sub <- lambda[-c(mask.out),-c(mask.out)]
    
    Omeg <- solve(sub.dat.sub%*%lambda.sub%*%t(sub.dat.sub) + (1e-5)*diag(nrow(sub.dat.sub)))
    beta_pms <- lambda.sub%*%t(sub.dat.sub)%*%Omeg%*%age_tab$age
    intercept <- mean(age_tab$age) - colMeans(sub.dat.sub)%*%beta_pms 
    
    beta <- c(intercept,beta_pms)
    train <- c(train,sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat.sub)%*%beta))^2)))
    test <- c(test,sqrt(mean((as.numeric(age_tab.test$age - cbind(1,sub.dat.test.sub)%*%beta))^2)))
  }
  out <- list()
  out$train <- train
  out$test <- test
  return(out)
}
```

```{r}
num.vox.vec <- (1:100)*10

res.lambda.ropca <- long.rmse.with.lambda(rank_beta_pms, num.vox.vec,lambda)
res.lambda.pca <- long.rmse.with.lambda(rank_beta_pms.normal, num.vox.vec,lambda.normal)

```

```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.lambda.ropca$train,res.lambda.pca$train,res.ridge$train))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(0,20) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```
```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.lambda.ropca$test,res.lambda.pca$test,res.ridge$test))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(5.5,15) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
PCA gets even worse
How is it that for robust pca, training rmse keeps increasing but test rmse keep decreasing

##Cross validation

Let's start with the simplest version:
 - Keep train, test the same (ie 50-50)
 - Only look at performance at 1000 selected variables
 
###simplest version
```{r}
library(rrcov)
simple.cv.robpca <- function(no.variable = 1000,theta.range = 10^seq(-9,1,1)){ #-9
  train <- vector(mode = 'numeric')
  test <- vector(mode = 'numeric')
  pca <- PcaHubert(sub.dat,kmax=100) 
  lambda <- pca$loadings %*% t(pca$loadings) 
  for(theta in theta.range){
    #doing PCA
    Omeg <- solve(sub.dat%*%lambda%*%t(sub.dat) + (theta)*diag(nrow(sub.dat))) #4x4 
    pre_beta_pms <- lambda%*%t(sub.dat)%*%Omeg #4 x 75
    beta_pms <- pre_beta_pms%*%age_tab$age
    rownames(beta_pms) <- colnames(sub.dat)
    rank_beta_pms <- beta_pms[order(abs(beta_pms), decreasing=TRUE),]
    
    #Doing prediction
    var.sel<- names(rank_beta_pms[1:no.variable])
    sub.dat.sub <- sub.dat
    sub.dat.test.sub <- sub.dat.test
    
    mask.out <- as.numeric(setdiff(colnames(sub.dat),var.sel))
    #print(head(mask.out))
    
    sub.dat.sub <- sub.dat.sub[,-c(mask.out)] 
    sub.dat.test.sub<- sub.dat.test.sub[,-c(mask.out)] 
    
    lambda.sub <- lambda[-c(mask.out),-c(mask.out)]
    
    Omeg <- solve(sub.dat.sub%*%lambda.sub%*%t(sub.dat.sub) + (theta)*diag(nrow(sub.dat.sub)))
    beta_pms <- lambda.sub%*%t(sub.dat.sub)%*%Omeg%*%age_tab$age
    intercept <- mean(age_tab$age) - colMeans(sub.dat.sub)%*%beta_pms 
    
    beta <- c(intercept,beta_pms)
    train <- c(train,sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat.sub)%*%beta))^2)))
    test <- c(test,sqrt(mean((as.numeric(age_tab.test$age - cbind(1,sub.dat.test.sub)%*%beta))^2)))
  }
  out <- rbind(theta.range,train,test)
  return(out)
}
```

```{r}
robpca.cv <- simple.cv.robpca()
```
Lowest theta is better, lowesr than this will lead to singularity

```{r}
simple.cv.pca <- function(no.variable = 1000,theta.range = 10^seq(-9,3,1)){
  train <- vector(mode = 'numeric')
  test <- vector(mode = 'numeric')
  pca <-  prcomp(sub.dat)
  lambda <- pca$rotation%*% t(pca$rotation)
  for(theta in theta.range){
    #doing PCA
    Omeg <- solve(sub.dat%*%lambda%*%t(sub.dat) + (theta)*diag(nrow(sub.dat))) #4x4 
    pre_beta_pms <- lambda%*%t(sub.dat)%*%Omeg #4 x 75
    beta_pms <- pre_beta_pms%*%age_tab$age
    rownames(beta_pms) <- colnames(sub.dat)
    rank_beta_pms <- beta_pms[order(abs(beta_pms), decreasing=TRUE),]
    
    #Doing prediction
    var.sel<- names(rank_beta_pms[1:no.variable])
    sub.dat.sub <- sub.dat
    sub.dat.test.sub <- sub.dat.test
    
    mask.out <- as.numeric(setdiff(colnames(sub.dat),var.sel))
    #print(head(mask.out))
    
    sub.dat.sub <- sub.dat.sub[,-c(mask.out)] 
    sub.dat.test.sub<- sub.dat.test.sub[,-c(mask.out)] 
    
    lambda.sub <- lambda[-c(mask.out),-c(mask.out)]
    
    Omeg <- solve(sub.dat.sub%*%lambda.sub%*%t(sub.dat.sub) + (theta)*diag(nrow(sub.dat.sub)))
    beta_pms <- lambda.sub%*%t(sub.dat.sub)%*%Omeg%*%age_tab$age
    intercept <- mean(age_tab$age) - colMeans(sub.dat.sub)%*%beta_pms 
    
    beta <- c(intercept,beta_pms)
    train <- c(train,sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat.sub)%*%beta))^2)))
    test <- c(test,sqrt(mean((as.numeric(age_tab.test$age - cbind(1,sub.dat.test.sub)%*%beta))^2)))
  }
  out <- rbind(theta.range,train,test)
  return(out)
}
```
```{r}
pca.cv <- simple.cv.pca() #theta = 10 is optimal
```

Now let's assess the outcome:
```{r}
long.rmse.with.lambda.theta <- function(lambda,theta,num.vox.vec){
  Omeg <- solve(sub.dat%*%lambda%*%t(sub.dat) + (theta)*diag(nrow(sub.dat))) #4x4 
  pre_beta_pms <- lambda%*%t(sub.dat)%*%Omeg #4 x 75
  beta_pms <- pre_beta_pms%*%age_tab$age
  rownames(beta_pms) <- colnames(sub.dat)
  rank_beta_pms <- beta_pms[order(abs(beta_pms), decreasing=TRUE),]
  train <- vector(mode = 'numeric')
  test <- vector(mode = 'numeric')
  for(i in num.vox.vec){
    var.sel<- names(rank_beta_pms[1:i])
    sub.dat.sub <- sub.dat
    sub.dat.test.sub <- sub.dat.test
    
    mask.out <- as.numeric(setdiff(colnames(sub.dat),var.sel))
    
    sub.dat.sub <- sub.dat.sub[,-c(mask.out)] 
    sub.dat.test.sub<- sub.dat.test.sub[,-c(mask.out)] 
    
    lambda.sub <- lambda[-c(mask.out),-c(mask.out)]
    
    Omeg <- solve(sub.dat.sub%*%lambda.sub%*%t(sub.dat.sub) + (theta)*diag(nrow(sub.dat.sub)))
    beta_pms <- lambda.sub%*%t(sub.dat.sub)%*%Omeg%*%age_tab$age
    intercept <- mean(age_tab$age) - colMeans(sub.dat.sub)%*%beta_pms 
    
    beta <- c(intercept,beta_pms)
    train <- c(train,sqrt(mean((as.numeric(age_tab$age - cbind(1,sub.dat.sub)%*%beta))^2)))
    test <- c(test,sqrt(mean((as.numeric(age_tab.test$age - cbind(1,sub.dat.test.sub)%*%beta))^2)))
  }
  out <- list()
  out$train <- train
  out$test <- test
  return(out)
}
```

```{r}
#Get lambda and lambda.normal
pca <- PcaHubert(sub.dat,kmax=100) 
lambda <- pca$loadings %*% t(pca$loadings) 

pca <-  prcomp(sub.dat)
lambda.normal <- pca$rotation%*% t(pca$rotation)
```


```{r}
num.vox.vec <- (1:100)*10

res.lambda.ropca <- long.rmse.with.lambda.theta(lambda, robpca.cv[1,which.min(robpca.cv[3,])], num.vox.vec)
res.lambda.pca <- long.rmse.with.lambda.theta(lambda.normal, pca.cv[1,which.min(pca.cv[3,])], num.vox.vec)

```

```{r}
library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.lambda.ropca$train,res.lambda.pca$train,res.ridge$train))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(0,10) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```
```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res.lambda.ropca$test,res.lambda.pca$test,res.ridge$test))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(5.5,10) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

#14 Apr
Running 
//apr14_cv_pms 53813310 ===> with res3 mask and saliency [failed to create viz due to out of memory but not sure where]

```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/apr14_cv_pms.csv")
```

```{r}
library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1:3,])
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(0,15) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```
```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[4:6,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(4.5,15) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```



#19 Apr
//apr19_cv_pms 54561372 ===> centre mask, with 2k train/test
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/apr19_cv_pms.csv")
```
```{r}
library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1:3,])
num.vox.vec <- (1:100)*10
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,13) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```
```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[4:6,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(4,12.5) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
looks alright

I need to incorporate double tuning for screening and predictions
//apr21_dcv_pms 54576737 ===> double cv
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/apr21_dcv_pms.csv")
```
```{r}
library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1:3,])
num.vox.vec <- (1:100)*10
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,13) +
  theme_minimal() +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```
```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[4:6,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(4,12.5) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```


//apr21_dcv_pms  54587542 ==> added viz, let's see.

#22 Apr
Perhaps extend this further, let's say 4k subjects.

see
```{r}
num.add <- 4000
part_use<- (read.csv('/well/nichols/users/qcv214/bnn2/add_1_part_id_use_final.txt')$V1)[1:num.add] #This file has 4258 additional subjects
list_of_all_images<-paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',part_use,'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz')
res3.dat <- rbind(res3.dat,as.matrix(fast_read_imgs_mask(list_of_all_images,'/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz')))
age_tab<- rbind(age_tab,(read_feather('/well/nichols/users/qcv214/bnn2/res3/age_add1.feather'))[1:num.add,]) #Need to fix this
```

##Testing more data
###What is originally here, with loading current data
```{r}
part_list<-read.table('/well/nichols/users/qcv214/Placement_2/participant_list.txt', header = FALSE, sep = "", dec = ".") #4529 participants
part_list$exist_vbm <- file.exists(paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',part_list[,1],'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz'))
#These two are equal
part_use<-part_list[part_list$exist_vbm==1,] #4262 participants left
#part_use<-part_use[1:200,] #only take 200
part_use<-part_use[1:4000,] #only take 4k

agetab<-read.table(file = '/well/nichols/projects/UKB/SMS/ukb_latest-Age.tsv', sep = '\t', header = TRUE)
age_tab<-as.data.frame(matrix(,nrow = length(part_use$V1),ncol = 2)) #id, age, number of masked voxels
colnames(age_tab)[1:2]<-c('id','age')
age_tab$id<-part_use$V1
for(i in 1:length(part_use$V1)){
  age_tab$age[i]<-agetab$X21003.2.0[agetab$eid_8107==sub(".", "",age_tab$id[i])]
}
#age_tab.test <- age_tab[101:200,]
#age_tab <- age_tab[1:100,]
age_tab.test <- age_tab[2001:4000,]
age_tab <- age_tab[1:2000,]
```
### More data
First needa check if their id overlap (don't want) //
```{r} 
age_tab2<-read_feather('/well/nichols/users/qcv214/bnn2/res3/age_add1.feather')
#sum(age_tab$id %in% age_tab2$id) =0 ==> no overlap
```

Found that some of the data on age_add1 is no longer there, let's create a new one.
```{r}
part_list2 <- read.csv('/well/nichols/users/qcv214/bnn2/add_1_part_id_use_final.txt')$V1 #4258
part_list2.exist_vbm <- file.exists(paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',part_list2,'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz')) #4257, only one person is missing
part_use2 <-part_list2[part_list2.exist_vbm]
part_use2 <- part_use2[1:4000]
###
age_tab2<-as.data.frame(matrix(,nrow = length(part_use2),ncol = 2)) #id, age, number of masked voxels
colnames(age_tab2)[1:2]<-c('id','age')
age_tab2$id<-part_use2
for(i in 1:length(part_use2)){
  age_tab2$age[i]<-agetab$X21003.2.0[agetab$eid_8107==sub(".", "",age_tab2$id[i])]
}
```
Sanity check for completness of extraction
`sum(c(is.na(age_tab2)))` = 0


//apr22_dcv_pms  54664383 ==> added 4k more training, so 6k in total, note that num.vox.vec is changed to `(1:100)*100`

#apr 23
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/apr23_dcv_pms.csv")
```
```{r}
library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1:3,])
num.vox.vec <- (1:100)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```
```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[4:6,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(4,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

#9 May

We want to try incorportaing response into the projection matrix. There are options:
1. Partial Least Squares
2. Canonical Correlation Analysis (CCA)
3. Supervised PCA 


##Prepping data
###Get the sub Mask
```{r}
mask_subcor<-oro.nifti::readNIfTI('/well/nichols/users/qcv214/PMS/mask_without_WM_and_stem_thrsholded.nii.gz')

submask <-array(0,dim=dim(mask_subcor))
submask[26:64,37:70,22:55] <- mask_subcor[26:64,37:70,22:55] 
table(submask[submask!=0]) #1613 voxels in total
length(submask[submask!=0]) #15,847 voxels

# writeNIfTI(submask,'/well/nichols/users/qcv214/pms2/sub150_centre_mask') #/well/nichols/users/qcv214/pms2

```

###Get age response
```{r}
part_list<-read.table('/well/nichols/users/qcv214/Placement_2/participant_list.txt', header = FALSE, sep = "", dec = ".") #4529 participants
part_list$exist_vbm <- file.exists(paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',part_list[,1],'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz'))
#These two are equal
part_use<-part_list[part_list$exist_vbm==1,] #4262 participants left
part_use<-part_use[1:200,] #only take 100

agetab<-read.table(file = '/well/nichols/projects/UKB/SMS/ukb_latest-Age.tsv', sep = '\t', header = TRUE)
age_tab<-as.data.frame(matrix(,nrow = length(part_use$V1),ncol = 2)) #id, age, number of masked voxels
colnames(age_tab)[1:2]<-c('id','age')
age_tab$id<-part_use$V1
for(i in 1:length(part_use$V1)){
  age_tab$age[i]<-agetab$X21003.2.0[agetab$eid_8107==sub(".", "",age_tab$id[i])]
}
age_tab.test <- age_tab[101:200,]
age_tab <- age_tab[1:100,]
```

###Get data 
```{r}
list_of_all_images<-paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',age_tab$id,'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz')
sub.dat <- as.matrix(fast_read_imgs_mask(list_of_all_images,'/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
colnames(sub.dat) <- as.character(1:ncol(sub.dat))
list_of_all_images<-paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',age_tab.test$id,'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz')
sub.dat.test <- as.matrix(fast_read_imgs_mask(list_of_all_images,'/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
colnames(sub.dat.test) <- colnames(sub.dat)
```


##Let's try PLS


```{r}
library(pls)

# Assuming 'X' is your predictor matrix and 'Y' is your response variable

# Perform PLS
pls_model <- plsr(age_tab$age ~ sub.dat)

# Projection of X onto the first few PLS components
scores <- scores(pls_model)

# Projection matrix
projection_matrix_pls <- loadings(pls_model) %*% t(loadings(pls_model)) #15847 x 15847

#print(projection_matrix_pls)

```


Running
//may9_dcv_pls_200 58015346 ==> 100 train subjects [super fast]
may9_dcv_pls 58020343 ==>6k subjects


##Result pls 200
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/may9_dcv_pls_200.csv")

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1,])
num.vox.vec <- (1:100)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("PLS")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

##########################################.      Test
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[2,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("PLS")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(4,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

##Result pls 6k
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/may9_dcv_pls.csv")

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1,])
num.vox.vec <- (1:100)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("PLS")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

##########################################.      Test
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[2,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("PLS")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(4,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```



###Old results (6k test subjects)
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/apr23_dcv_pms.csv")
```
```{r}
library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1:3,])
num.vox.vec <- (1:100)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

```
```{r}
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[4:6,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(4,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

Running
//may9_dcv_spca 58149945

##Result spca 6k
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/may9_dcv_spca.csv")

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1,])
num.vox.vec <- (1:100)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("SPCA")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

##########################################.      Test
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[2,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("SPCA")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(4,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

#14 May

Aggregate the result
```{r}
library(ggplot2)
library(tidyr)
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/apr23_dcv_pms.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/may9_dcv_pls.csv")
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/may9_dcv_spca.csv")


# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[1:3,],res2[1,],res3[1,]))
num.vox.vec <- (1:100)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge','PLS','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")


# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[4:6,],res2[2,],res3[2,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge','PLS','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  ylim(4,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

Use ridge to make predictions to make all methods comparaable, this is a variable screening exercise, not prediction

Running cv_pms2.R to obtain  ===> robca, pca, pls, spca for variable screening, then Ridge for prediction
`may27_cv_pms`



I keep running into problem. Here is a smaller version (500 train, 100 test) `cv_pms_600`
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/may27_cv_pms_600.csv")

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1:5,])
num.vox.vec <- (1:100)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge','PLS','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[6:10,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge','PLS','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```






may27_cv_pms 61402365 ==> 6k data 

#2 June

2 methods (SPCA) methods since last meeting
- Fit Ridge on X,Y => Re-weight X => Screen out new X based on magnitude => Fit Robust PCA
- Fit ridge to screen out => apply SPCA

Let's try the first way on 4 test, 2 train?
```{r}
part_list<-read.table('/well/nichols/users/qcv214/Placement_2/participant_list.txt', header = FALSE, sep = "", dec = ".") #4529 participants
part_list$exist_vbm <- file.exists(paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',part_list[,1],'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz'))
#These two are equal
part_use<-part_list[part_list$exist_vbm==1,] #4262 participants left
part_use<-part_use[1:6,] #only take 200
# part_use<-part_use[1:4000,] #only take 4k

agetab<-read.table(file = '/well/nichols/projects/UKB/SMS/ukb_latest-Age.tsv', sep = '\t', header = TRUE)
age_tab<-as.data.frame(matrix(,nrow = length(part_use$V1),ncol = 2)) #id, age, number of masked voxels
colnames(age_tab)[1:2]<-c('id','age')
age_tab$id<-part_use$V1
for(i in 1:length(part_use$V1)){
  age_tab$age[i]<-agetab$X21003.2.0[agetab$eid_8107==sub(".", "",age_tab$id[i])]
}
age_tab.test <- age_tab[5:6,]
age_tab <- age_tab[1:4,]
n.train <- nrow(age_tab)

list_of_all_images<-paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',age_tab$id,'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz')
sub.dat <- as.matrix(fast_read_imgs_mask(list_of_all_images,'/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
# sub.dat <- as.matrix(fast_read_imgs_mask(list_of_all_images,'/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz'))

colnames(sub.dat) <- as.character(1:ncol(sub.dat))
list_of_all_images<-paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',age_tab.test$id,'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz')
sub.dat.test <- as.matrix(fast_read_imgs_mask(list_of_all_images,'/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
# sub.dat.test <- as.matrix(fast_read_imgs_mask(list_of_all_images,'/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz'))

colnames(sub.dat.test) <- colnames(sub.dat)

cv_model <- cv.glmnet(sub.dat, age_tab$age, alpha = 0, nfolds = 10)
# Best lambda from cross-validation
coefficients <- coef(cv_model, s = "lambda.min")  # Extract coefficients at best lambda
weights <- abs(coefficients[-1,])  # Exclude intercept from weights (first row of coefficients)
X_weighted <- scale(sub.dat) * sqrt(weights) #there are 192 NAs in scale(sub.dat) but i dont know where *I believe it's to do with the column being a constant

#Question is do I rank the voxels by col mean or col var. I am guessing it's col var
colvar <- apply(X_weighted,MARGIN = 2, var)

rank_var.ridge <- colvar[order(colvar, decreasing=TRUE)]
var.sel<- names(rank_var.ridge[1:round(length(colvar)*0.3)]) #take only 30% of voxel

X_weighted_sel <- X_weighted[,var.sel]

pca <- PcaHubert(X_weighted_sel,kmax=min(n.train, length(var.sel))) 
lambda. <- pca$loadings %*% t(pca$loadings) 
```

Running
`june2_cv_pms_ridgeSRPCA` from `cv_pms2_rsrpca` 61555120 ==> exceeded time limit??


#5 june
may27_cv_pms takes like 15-17 hours
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/may27_cv_pms.csv")

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1:5,])
num.vox.vec <- (1:100)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge','PLS','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[6:10,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge','PLS','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```


#9 June
Let's try fast MCD method to derive a robust covariance matrix then construct PCA
```{r}
# Load the necessary libraries
library(robustbase)
library(stats)

# Load and prepare your data
data <- mtcars

# Compute the MCD covariance matrix
mcd_result <- covMcd(data)
mcd_cov <- mcd_result$cov

# Perform eigen decomposition on the covariance matrix
eig_decomp <- eigen(mcd_cov)

# Extract the eigenvectors
eigenvectors <- eig_decomp$vectors

# The eigenvectors form the projection matrix
projection_matrix <- eigenvectors

# Print the projection matrix
print("Projection Matrix (Eigenvectors):")
print(projection_matrix)

# Center the data using the robust center
data_centered <- scale(data, center = mcd_result$center, scale = FALSE)

# Project the centered data onto the principal components
pca_scores <- data_centered %*% projection_matrix

# Print the first few principal component scores
print("Principal Component Scores:")
print(head(pca_scores))
```

Running 
june9_cv_pms_ridgeSMCDPCA 62725139

When I tried to run `june9_cv_pms_ridgeSMCDPCA_600`, I got this error from `covMcd(X_weighted_sel)` saying `Error in covMcd(X_weighted_sel) : n <= p -- you can't be serious!`.


10/6/2024
Tom's suggestion: use rank transofrmation (see Teams)
So across subjects, for each voxel, apply this transformation to transform the data (to get rid of outliers), then apply PCA.




#11 June
trying ridge +SPCA or ridge + SRPCA
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/may27_cv_pms_600.csv")
res2<- read.csv("/well/nichols/users/qcv214/pms2/pile/june11_cv_pms_ridgeSPCA_600.csv") #max 4700 variables
res2<-  cbind(res2,matrix(data=NA,nrow=nrow(res2), ncol = (length(res)-length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/june11_cv_pms_ridgeSRPCA_600.csv")
res3<-  cbind(res3,matrix(data=NA,nrow=nrow(res3), ncol = (length(res)-length(res3))))
colnames(res3) <- colnames(res)

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[1:5,],res2[1,],res3[1,]))
num.vox.vec <- (1:100)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge','PLS','SPCA',"Ridge+SPCA","Ridge+SRPCA")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[6:10,],res2[2,],res3[2,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c("RoPCA",'PCA','Ridge','PLS','SPCA',"Ridge+SPCA","Ridge+SRPCA")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```


##Quantile normalisation
Correcting outlier in data across subjects for each voxels

`bestNormalize` not available
```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(bestNormalize)
inorm <- function(x) {
  orderNorm(x,warn=FALSE)$x.t * sd(x,na.rm=TRUE) + mean(x,na.rm=TRUE)
}
```


```{r}
# Quantile normalization function for a vector using inverse CDF of standard Gaussian
quantile_normalize_vector <- function(x) {
  # Remove NA values and get their ranks
  na_idx <- is.na(x)
  x_no_na <- x[!na_idx]
  
  # Compute the ranks
  ranks <- rank(x_no_na, ties.method = "average")
  
  # Map ranks to uniform [0, 1] probabilities
  n <- length(x_no_na)
  uniform_probs <- (ranks - 0.5) / n
  
  # Apply the inverse CDF of the standard Gaussian distribution
  normal_scores <- qnorm(uniform_probs)
  
  # Normalize to the original scale
  x_normalized <- normal_scores * sd(x_no_na, na.rm = TRUE) + mean(x_no_na, na.rm = TRUE)
  
  # Reinsert NA values in the original positions
  result <- x
  result[!na_idx] <- x_normalized
  
  return(result)
}

# Sample data (vector)
set.seed(123)
data_vector <- runif(10)

# Perform quantile normalization
data_normalized <- quantile_normalize_vector(data_vector)

# Print the original and normalized data
print("Original Data:")
print(data_vector)

print("Quantile Normalized Data:")
print(data_normalized)

```
I think the above is correct by inspect qqnorm of data_vector and data_normalized



//june15_cv_pms_full.csv 64932719 => num vox = (1:50)*200, num samples = 2k train, 2k test.

```{r}
plot(res[1:3,])
par("mar")
```

#19 june

** I accidentally used num.vox.vec = (1:50)*200 for ridge but not other methods

```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/june15_cv_pms_full.csv")

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1:3,])
num.vox.vec <- (1:100)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA','Ridge','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[4:6,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA','Ridge','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/june15_cv_pms_full.csv")
colnames(res) <- NULL
library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(c(res[1,seq(2,100,2)]), res[2,1:50],c(res[3,seq(2,100,2)])))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA','Ridge','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(c(res[4,seq(2,100,2)]), res[5,1:50],c(res[6,seq(2,100,2)])))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA','Ridge','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

The jump is still there.

Running 
june19_cv_pms_full. 65002128 => fixing num.vox.vec and change cv.glmnet to glmnet

```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/june19_cv_pms_full.csv")

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1:3,])
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA','Ridge','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[4:6,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA','Ridge','SPCA')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

This is totally weird. Something really happens at 2k variables

#21 June
##To do
1. Observe the jump => I think it's when p >= n in ridge prediction. For 600 samples and 2k samples, this happens exactly wheb n=p, for 6k training, it happens at p = 5.5k 
2. Do SPCA with 80% or 90% variance explained
3. Perform smoothing prior to SPCA


#2 july

## PCA and SPCA at 80% and 90%
Running 
[failed] july2_cv_pms8090_full 152987  => first ran into OOM issue, soenow im assigning all variables to the same variable to avoid multiple storing
//july2_cv_pms8090_full 236057
## Smoothing 
```{r}
# Function to apply 3D smoothing using a manual convolution with averaging kernel
smooth_3d_matrix_manual <- function(data) {
  # Define a 3x3x3 averaging kernel
  kernel <- array(1/27, dim = c(3, 3, 3))
  
  # Get the dimensions of the data
  dims <- dim(data)
  
  # Pad the data with zeros on all sides
  padded_data <- array(0, dim = dims + 2)
  padded_data[2:(dims[1]+1), 2:(dims[2]+1), 2:(dims[3]+1)] <- data
  
  # Initialize the smoothed data array
  smoothed_data <- array(0, dim = dims)
  
  # Apply the convolution manually
  for (x in 2:(dims[1]+1)) {
    for (y in 2:(dims[2]+1)) {
      for (z in 2:(dims[3]+1)) {
        # Extract the 3x3x3 neighborhood
        neighborhood <- padded_data[(x-1):(x+1), (y-1):(y+1), (z-1):(z+1)]
        
        # Compute the mean of the neighborhood
        smoothed_data[x-1, y-1, z-1] <- sum(neighborhood * kernel)
      }
    }
  }
  
  return(smoothed_data)
}

# Example usage with a 3D matrix
set.seed(123)
data_3d <- array(rnorm(5 * 5 * 5), dim = c(5, 5, 5))

# Apply the smoothing function
smoothed_data_3d <- smooth_3d_matrix_manual(data_3d)

# Print the original and smoothed data
print("Original Data:")
print(data_3d)

print("Smoothed Data:")
print(smoothed_data_3d)
```



#8 July

##PCA 80 and 90
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/july2_cv_pms8090_full.csv")

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(res[1:4,])
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 80', 'PCA 90','SPCA 80','SPCA 90')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(as.data.frame(res[5:8,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 80', 'PCA 90','SPCA 80','SPCA 90')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Note that these methods don't do CV during predictions. 
Observable increase in RMSE when p -> n 

##Combine all results
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/june19_cv_pms_full.csv")
res2<- read.csv("/well/nichols/users/qcv214/pms2/pile/july2_cv_pms8090_full.csv")
res2<-  cbind(res2,matrix(data=NA,nrow=nrow(res2), ncol = (length(res)-length(res2))))
colnames(res2) <- colnames(res)

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[1:3,],res2[1:4,]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 100','Ridge','SPCA 100','PCA 80', 'PCA 90','SPCA 80','SPCA 90')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[4:6,],res2[5:8,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 100','Ridge','SPCA 100','PCA 80', 'PCA 90','SPCA 80','SPCA 90')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

#9 July
Tom suggests 2 packages for smoothing
`mmand`  => package ‘mmand’ is not available for this version of R 
`https://github.com/jonclayden/mmand` for examples

and `fslr` (doing fsl in r) => package ‘fslr’ is not available for this version of R

Maybe try another version of R?. Let me create a dummie file to run on the cluster. using `test_r.sh` and `code/test_r.R`

```{r}
install.packages("fslr")
```

Just realised that my data is stored in a 1d format, ie no 3D sense...
Perhaps I can fast load the data into a vector, stack as a 2D matrix as already done. Then for each row, turn it back into a nifti image using template, apply smoothing, turn it back into a vector

First need to check if vbm is already pre-smoothed tho... I think it's pre-smoothed. VBM involved smoothing techniques, and in `sample_brains/`, data also look smooth

Also `PMS` for loading images + other basic libraries and `mmand` and `fslr` are not avail in the same version of R so I can't run!!


#16 July
Let's try loading an old `mmand`

##Note
I ended up loading mmand locally, upload the package .tar.gz to the cluster and install it from there.
```{r}
packageurl <- "https://cran.r-project.org/src/contrib/Archive/mmand/mmand_1.6.1.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
```
```{r}
require(remotes)
install_version("mmand", version = "1.6.3", repos = "http://cran.us.r-project.org")
```

```{r}
# Install devtools package if not already installed
if (!requireNamespace("devtools", quietly = TRUE)) {
  install.packages("devtools")
}

# Load devtools library
library(devtools)
```
https://cran.r-project.org/src/contrib/Archive/mmand/mmand_1.6.2.tar.gz

```{r}
# Define the URL for the specific version of mmand
url <- "https://cran.r-project.org/src/contrib/Archive/mmand/mmand_1.6.1.tar.gz"

# Install the specific version from the URL
install.packages(url, repos = NULL, type = "source")
```
```{r}
# Replace 'path/to/mmand_1.6.2.tar.gz' with the actual path to the downloaded file
local_file_path <- "/well/nichols/users/qcv214/pms2/package/mmand_1.6.2.tar.gz"
install.packages(local_file_path, repos = NULL, type = "source")
```


##test mmand
from file `test_r.R`
```{r}
x <- seq(0, 4*pi, pi*2)
y1 <- cos(x) + runif(length(x),-0.2,0.2) *100
y2 <- cos(x) + runif(length(x),-0.5,0.5) *100
y3 <- cos(x) + runif(length(x),-0.9,0.9) *100

# y <- matrix(c(y1,y2,y3),byrow=TRUE,nrow=3)
#3rd dim, only 2 of them
y <- array(c(y1,y2,y3,y3,y2), dim = c(3,3,2))
y_smoothed <- gaussianSmooth(y, c(1,1,1))
print("done x ")
print(x)
print("done y ")
print(y)
print("done y___")
print(y_smoothed)
print("done")
```



//july17_cv_pms8090_full_smooth. 1511044 (previous job got oom halfway, at 16gb)

#20 July

##Observe effect of smoothing 80 and 90 
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/july2_cv_pms8090_full.csv")
res2<- read.csv("/well/nichols/users/qcv214/pms2/pile/july17_cv_pms8090_full_smooth.csv")
res2<-  cbind(res2,matrix(data=NA,nrow=nrow(res2), ncol = (length(res)-length(res2))))
colnames(res2) <- colnames(res)

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[1:4,],res2[1:4,]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 80', 'PCA 90','SPCA 80','SPCA 90','Smooth_PCA 80', 'Smooth_PCA 90','Smooth_SPCA 80','Smooth_SPCA 90')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[5:8,],res2[5:8,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 80', 'PCA 90','SPCA 80','SPCA 90','Smooth_PCA 80', 'Smooth_PCA 90','Smooth_SPCA 80','Smooth_SPCA 90')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```


##use Smoothed results
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/june19_cv_pms_full.csv")
res2<- read.csv("/well/nichols/users/qcv214/pms2/pile/july17_cv_pms8090_full_smooth.csv")
res2<-  cbind(res2,matrix(data=NA,nrow=nrow(res2), ncol = (length(res)-length(res2))))
colnames(res2) <- colnames(res)

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[1:3,],res2[1:4,]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 100','Ridge','SPCA 100','Smooth_PCA 80', 'Smooth_PCA 90','Smooth_SPCA 80','Smooth_SPCA 90')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[4:6,],res2[5:8,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 100','Ridge','SPCA 100','Smooth_PCA 80', 'Smooth_PCA 90','Smooth_SPCA 80','Smooth_SPCA 90')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Smooth SPCA 90 is promising.

Smoothing works. Now we should look at the selected voxels. Plot this.

july20_cv_pms8090_full_smooth 1779108 (and viz july20)

//smooth_brain_gen.R 1852500

#22 July
The smooth brains look decent. Sample 1 and 2 looks fairly different tho, i.e. entirely different hotspots

##use Smoothed results
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/june19_cv_pms_full.csv")
res2<- read.csv("/well/nichols/users/qcv214/pms2/pile/july20_cv_pms8090_full_smooth.csv")
res2<-  cbind(res2,matrix(data=NA,nrow=nrow(res2), ncol = (length(res)-length(res2))))
colnames(res2) <- colnames(res)

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[1:3,],res2[1:5,]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 100','Ridge','SPCA 100','Smooth_PCA 80', 'Smooth_PCA 90','Smooth_SPCA 80','Smooth_SPCA 90','Smooth_Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[4:6,],res2[6:10,]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 100','Ridge','SPCA 100','Smooth_PCA 80', 'Smooth_PCA 90','Smooth_SPCA 80','Smooth_SPCA 90','Smooth_Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Note June 19 uses 8k data. Need to tune it to 4k

//july22_cv_pms90_full 1939444[failed saved end result], 2026143 ==> has viz too


##use Smoothed results
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/july22_cv_pms90_full.csv")
res2<- read.csv("/well/nichols/users/qcv214/pms2/pile/july20_cv_pms8090_full_smooth.csv")
res2<-  cbind(res2,matrix(data=NA,nrow=nrow(res2), ncol = (length(res)-length(res2))))
colnames(res2) <- colnames(res)

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[1:3,],res2[c(2,4,5),]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[4:6,],res2[c(7,9,10),]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

#25 July
Use ridge for SPCA ===> nope, my original result was already using Ridge.

##To do
Compare this to pms
//july26_nbpms_full. 2575127 ===> failed to save pms.boot viz but everything else worked.


#27 July

##PMS
```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/july22_cv_pms90_full.csv")
res2<- read.csv("/well/nichols/users/qcv214/pms2/pile/july20_cv_pms8090_full_smooth.csv")
res2<-  cbind(res2,matrix(data=NA,nrow=nrow(res2), ncol = (length(res)-length(res2))))
colnames(res2) <- colnames(res)

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[1:3,],res2[c(2,4,5),]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[4:6,],res2[c(7,9,10),]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

```{r}
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/july22_cv_pms90_full.csv")
res2<- read.csv("/well/nichols/users/qcv214/pms2/pile/july20_cv_pms8090_full_smooth.csv")
res2<-  cbind(res2,matrix(data=NA,nrow=nrow(res2), ncol = (length(res)-length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/july26_nbpms_full.csv")
res3<-  cbind(res3,matrix(data=NA,nrow=nrow(res3), ncol = (length(res)-length(res3))))
colnames(res3) <- colnames(res)

library(ggplot2)
library(tidyr)
# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[1:3,],res2[c(2,4,5),],res3[1:3, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp','PMS_boots')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(2,7) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(rbind(res[4:6,],res2[c(7,9,10),],res3[4:6, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp','PMS_boots')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  # scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 100)) +
  # ylim(0,50) +
  theme_minimal() +
  scale_x_continuous(breaks=seq(0, 10000, 1000))+
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

Bottom two lines are still ridge and smooth SPCA
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/july22_cv_pms90_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/july20_cv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/july26_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
                   "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
                   "Smooth_Ridge" = "#FFFF33", "PMS" = "#A65628", 
                   "PMS_holp" = "#F781BF", "PMS_boots" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(2, 4, 5),], res3[1:3, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp','PMS_boots')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(7, 9, 10),], res3[4:6, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp','PMS_boots')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

#2 Aug

i am starting to suspect if i Need to add mu to the data approx for PCA method in the lambda. If lambda is a proj matrix then its fine, but if its data approx then may need to add mu

e.g. lambda.80 <- `pca$rotation[, 1:num_components.90]%*% t(pca$rotation[, 1:num_components.90])` become `lambda.80 <- pca$rotation[, 1:num_components.90]%*% t(pca$rotation[, 1:num_components.90])` + mu


[failed, oom] aug2_mu_cv_pms90_full 3063946
[failed oom] aug2_mu_cv_pms90_full_smooth 3063953

[failed, solving error and mem] aug2_mu_cv_pms90_full 3445663=> test 40 slots
[failed, solving error and mem] aug2_mu_cv_pms90_full_smooth 3445656 => test 40 slots


#4 Aug

##Metrics
Let's look at the "relative importance index" as in PMS's paper

###Test RRI 
from GPT
```{r}
# Function to calculate the Relative Importance Index (RRI)
rri <- function(method, mask, num.vox = 10000) {
  # Rank the voxel values in descending order
  ranked_indices <- order(method, decreasing = TRUE)
  
  # Select the top num.vox indices
  top_voxels <- ranked_indices[1:num.vox]
  
  # Calculate the total number of voxels per region
  region_voxel_counts <- as.data.frame(table(mask))
  colnames(region_voxel_counts) <- c("Region", "Total_Voxels")
  
  # Calculate the number of selected top voxels per region
  top_voxel_counts <- as.data.frame(table(mask[top_voxels]))
  colnames(top_voxel_counts) <- c("Region", "Top_Voxels")
  
  # Merge the tables, ensuring all regions are included
  merged_counts <- merge(region_voxel_counts, top_voxel_counts, by = "Region", all.x = TRUE)
  merged_counts$Top_Voxels[is.na(merged_counts$Top_Voxels)] <- 0
  
  # Calculate the percentage of selected voxels per region
  merged_counts$Pct_Top_Voxels <- merged_counts$Top_Voxels / sum(merged_counts$Top_Voxels)
  
  # Calculate the overall percentage of voxels per region
  merged_counts$Pct_Total_Voxels <- merged_counts$Total_Voxels / sum(merged_counts$Total_Voxels)
  
  # Compute the Relative Importance Index (RRI)
  merged_counts$RRI <- merged_counts$Pct_Top_Voxels / merged_counts$Pct_Total_Voxels
  
  # Return the RRI for each region
  return(merged_counts[, c("Region", "RRI")])
}

# Example usage
method <- c(10, 5, 3, 4, 2, 6, 7, 8, 19, 11)
mask <- c(2, 2, 1, 1, 1, 3, 3, 3, 3, 3)
num.vox <- 5

rri(method, mask, num.vox)
```
I believe that this is correct. I have verified.

####Plotting
```{r}
library(ggplot2)
rri_result <- rri(method, mask, num.vox)

# Convert Region to a factor to maintain order in the plot
rri_result$Region <- factor(rri_result$Region, levels = rri_result$Region)

# Create the bar plot with numerical values on top of each bar
ggplot(rri_result, aes(x = Region, y = RRI)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "black") +
  geom_text(aes(label = sprintf("%.2f", RRI)), 
            vjust = -0.3, color = "black", size = 3.5) +
  theme_minimal() +
  labs(title = "Relative Importance Index of Each Region",
       x = "Region",
       y = "Relative Importance Index")
```

Define a function called `rri_plot`
```{r}
# Load necessary library
library(ggplot2)

# Function to create the RRI bar plot
rri_plot <- function(rri_result, title_suffix) {
  # Convert Region to a factor with numeric levels to maintain order in the plot
  rri_result$Region <- factor(rri_result$Region, levels = sort(as.numeric(as.character(rri_result$Region))))
  
  # Create the title by concatenating the base title with the provided suffix
  plot_title <- paste("Relative Importance Index of Each Region:", title_suffix)
  
  # Create the bar plot with numerical values on top of each bar
  ggplot(rri_result, aes(x = Region, y = RRI)) +
    geom_bar(stat = "identity", fill = "skyblue", color = "black") +
    geom_text(aes(label = sprintf("%.2f", RRI)), 
              vjust = -0.3, color = "black", size = 3.5) +
    # geom_line() +
    geom_hline(aes(yintercept = 1, color = "RRI = 1"), linetype = "dashed", size = 1) +
    ylim(0,11) +
    theme_minimal() +
    labs(title = plot_title,
         x = "Region",
         y = "Relative Importance Index")
}
```

###apply this to our saved images

RRI of each method:
```{r}
#mask
res3.mask <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz','/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz'))
print(table(res3.mask)*100/length(res3.mask))
#smooth SPCA90
dat <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/smooth/july20_smooth_SPCA90.nii.gz','/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz'))
rri_result <- rri(dat, res3.mask, num.vox = 10000)
rri_plot(rri_result, "Smooth SPCA90")

#smooth SPCA80
dat <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/smooth/july20_smooth_SPCA80.nii.gz','/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz'))
rri_result <- rri(dat, res3.mask, num.vox = 10000)
rri_plot(rri_result, "Smooth SPCA80")

#Ridge
dat <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/july22_ridge.nii.gz','/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz'))
rri_result <- rri(dat, res3.mask, num.vox = 10000)
rri_plot(rri_result, "Ridge")

#Smooth ridge
dat <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/smooth/july20_smooth_ridge.nii.gz','/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz'))
rri_result <- rri(dat, res3.mask, num.vox = 10000)
rri_plot(rri_result, "Smooth Ridge")

#PMS
dat <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/july26_pms_hi.nii.gz','/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz'))
rri_result <- rri(dat, res3.mask, num.vox = 10000)
rri_plot(rri_result, "PMS")

#HOLP
dat <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/july26_pms_holp.nii.gz','/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz'))
rri_result <- rri(dat, res3.mask, num.vox = 10000)
rri_plot(rri_result, "HOLP")
```

We can see that PMS and HOLP have RRI not so far from 1 in each region, whereas other methods have high RRI
Though HOLP shouldn't be using spatial info, so im not sure why it acts differently.



#6 aug
Assessing affect of re-centering in approx matrix on sub mask since full mask keeps going oom

First time, both faile due to singularity occurred when solving. I have changed theta.range starting from -4 to -1
//aug2_mu_cv_pms90_sub150  3710352
//aug2_mu_cv_pms90_sub150_smooth 3710342


##Adding mu

```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug2_mu_cv_pms90_sub150.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug2_mu_cv_pms90_sub150_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)

# Define custom color palette
# custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
#                    "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
#                    "Smooth_Ridge" = "#FFFF33", "PMS" = "#A65628", 
#                    "PMS_holp" = "#F781BF", "PMS_boots" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[1:5,], res2[c(1:5),]))
num.vox.vec <- (1:50)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','PCA 90 mu','SPCA 90','SPCA 90 mu','Ridge', 'Smooth_PCA 90', 'Smooth_PCA 90 mu','Smooth_SPCA 90','Smooth_SPCA 90 mu','Smooth_Ridge')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 5000, 1000)) +
  # scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[6:10,], res2[c(6:10),]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','PCA 90 mu','SPCA 90','SPCA 90 mu','Ridge', 'Smooth_PCA 90', 'Smooth_PCA 90 mu','Smooth_SPCA 90','Smooth_SPCA 90 mu','Smooth_Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 5000, 1000)) +
  # scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Mu and no mu almost no effect on screening

Here SPCA mu is better than SPCA at first, but eventually converge.

##Actually
We don't need mu, and it's wrong

Data approx matrix = Data*Projection matrix + mu 
`https://stats.stackexchange.com/questions/229092/how-to-reverse-pca-and-reconstruct-original-variables-from-several-principal-com`

but what we need is just the projection matrix, so we had been doing it right.


#8 Aug

Check for PSD and symmetry of Projectio Matrix

I want to assess the PD and symmetry property of the projection matrix of PCA (UUt) where U is the pc$rotation. Can you write me an assessment for two cases. The first case being X is a 10 x 15 matrix where each entry is iid uniform [0,1], apply PCA using prcomp, only keep rotation that explains 90% of cumulative variance, check if the matrix is symmetric and if it is positive definite or positive semi definite, do another case but using data from iid normal(0,1)
```{r}
# Load necessary library
library(ggplot2)

# Function to assess PD and symmetry properties of the projection matrix
assess_projection_matrix <- function(X) {
  # Apply PCA
  pca_result <- prcomp(X, center = TRUE, scale. = TRUE)
  # Calculate the cumulative variance explained
  cum_variance <- cumsum(pca_result$sdev^2 / sum(pca_result$sdev^2))
  # Keep components that explain 90% of the variance
  num_components <- which(cum_variance >= 0.90)[1]
  U <- pca_result$rotation[, 1:num_components]
  # Construct the projection matrix
  projection_matrix <- U %*% t(U)
  # Check if the matrix is symmetric
  is_symmetric <- all.equal(projection_matrix, t(projection_matrix))
  # Check if the matrix is positive definite or positive semi-definite
  eigenvalues <- round(eigen(projection_matrix)$values,8)
  is_positive_definite <- all(eigenvalues > 0)
  is_positive_semi_definite <- all(eigenvalues >= 0)
  
  # Print results
  cat("Symmetric:", is_symmetric, "\n")
  cat("Positive Definite:", is_positive_definite, "\n")
  cat("Positive Semi-Definite:", is_positive_semi_definite, "\n")
}

# Case 1: Uniform [0,1] Distribution
set.seed(123)
X_uniform <- matrix(runif(10 * 15), nrow = 10, ncol = 15)
cat("Case 1: Uniform [0,1] Distribution\n")
assess_projection_matrix(X_uniform)

# Case 2: Normal (0,1) Distribution
set.seed(123)
X_normal <- matrix(rnorm(10 * 15), nrow = 10, ncol = 15)
cat("Case 2: Normal (0,1) Distribution\n")
assess_projection_matrix(X_normal)
```
So, from manual inspection, UUT will have positive eigenvalues same as number of selected PCs, the rest will be 0 (or very near 0 by numerical computation). Making this projecting a PSD matrix.

"Any covariance matrix is symmetric and positive semi-definite"

Thus, our projection matrix must be a valid covariance!!

#12 Aug

Run stability (empirical)

Look at simulation, maybe just sub.mask
1. fix one region => with varying addition to observe sensitivity to SNR
2. or impose a spatial decay ("Gaussian blob") => to add spatial complexity
3. case of 2 disjoint regions?

We will do both


#Simulation study

##Look at data
Look at VBM summary of first two subjeccts
```{r}
part_list<-read.table('/well/nichols/users/qcv214/Placement_2/participant_list.txt', header = FALSE, sep = "", dec = ".") #4529 participants
part_list$exist_vbm <- file.exists(paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',part_list[,1],'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz'))
#These two are equal
part_use<-part_list[part_list$exist_vbm==1,] #4262 participants left
# part_use<-part_use[1:200,] #only take 200
part_use<-part_use[1:4000,] #only take 4k

agetab<-read.table(file = '/well/nichols/projects/UKB/SMS/ukb_latest-Age.tsv', sep = '\t', header = TRUE)
age_tab<-as.data.frame(matrix(,nrow = length(part_use$V1),ncol = 2)) #id, age, number of masked voxels
colnames(age_tab)[1:2]<-c('id','age')
age_tab$id<-part_use$V1
for(i in 1:length(part_use$V1)){
  age_tab$age[i]<-agetab$X21003.2.0[agetab$eid_8107==sub(".", "",age_tab$id[i])]
}
# age_tab.test <- age_tab[101:200,]
# age_tab <- age_tab[1:100,]
age_tab <- age_tab[1:2,]

list_of_all_images<-paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',age_tab$id,'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz')
sub.dat <- as.matrix(fast_read_imgs_mask(list_of_all_images,'/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
colnames(sub.dat) <- as.character(1:ncol(sub.dat))
```
So sub.dat is 2 x 15k, look at row-wise summary

```{r}
for( i in 1:2){
  print(summary(sub.dat[i,]))
}
```

```{r}
mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))

hist(mask.vec)
table(mask.vec)
```

By looking at FSLEYES and table(). I think I might use region 2, which is about 29% of the mask. Though it has very bad curvature.
I think I will use region 4 + 15, basically the centre of the brain, about 12% of the mask

```{r}
table(mask.vec[mask.vec %in% c(4,15)])
```


// sim_aug13_str3_pms90.csv 4652610 [from sim_binmask_oms2_pca] =>

```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug13_str3_pms90.csv")
# res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug2_mu_cv_pms90_sub150_smooth.csv")
# res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
# colnames(res2) <- colnames(res)

# Define custom color palette
# custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
#                    "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
#                    "Smooth_Ridge" = "#FFFF33", "PMS" = "#A65628", 
#                    "PMS_holp" = "#F781BF", "PMS_boots" = "#999999")

# First plot
# resdat <- as.data.frame(rbind(res[1:5,], res2[c(1:5),]))
resdat <- as.data.frame(rbind(res[1:3,]))
num.vox.vec <- (1:20)*100
colnames(resdat) <- num.vox.vec
# resdat$row_id <- c('PCA 90','PCA 90 mu','SPCA 90','SPCA 90 mu','Ridge', 'Smooth_PCA 90', 'Smooth_PCA 90 mu','Smooth_SPCA 90','Smooth_SPCA 90 mu','Smooth_Ridge')
resdat$row_id <- c('PCA 90','SPCA 90','Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 2000, 500)) +
  # scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
# resdat <- as.data.frame(rbind(res[6:10,], res2[c(6:10),]))
resdat <- as.data.frame(rbind(res[4:6,]))

colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 2000, 500)) +
  # scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
We can see that PCA and SPCA are better than ridge at first.
I think overall, we still want p >> n. Perhaps decrease n to about 500?


//sim_aug13_500_str3_ 4652784
//sim_aug13_500_str3_.... smooth. 4652832

```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug13_500_str3_pms90.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug13_500_str3_pms90_smooth.csv")
# res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)

# Define custom color palette
# custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
#                    "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
#                    "Smooth_Ridge" = "#FFFF33", "PMS" = "#A65628", 
#                    "PMS_holp" = "#F781BF", "PMS_boots" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),]))
# resdat <- as.data.frame(rbind(res[1:3,]))
num.vox.vec <- (1:20)*100
colnames(resdat) <- num.vox.vec
# resdat$row_id <- c('PCA 90','PCA 90 mu','SPCA 90','SPCA 90 mu','Ridge', 'Smooth_PCA 90', 'Smooth_PCA 90 mu','Smooth_SPCA 90','Smooth_SPCA 90 mu','Smooth_Ridge')
resdat$row_id <- c('PCA 90','SPCA 90','Ridge','PCA 90 Smooth','SPCA 90 Smooth','Ridge Smooth')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 2000, 500)) +
  # scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),]))
# resdat <- as.data.frame(rbind(res[4:6,]))

colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge','PCA 90 Smooth','SPCA 90 Smooth','Ridge Smooth')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 2000, 500)) +
  # scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Let's see if we can do double cv here... 

I have a feeling that the saving of spca smooth is. wrong for viz

Right now smoothing is done before defining output, meaning that smoothing makes voxels look even more similar, easier to predict
However
1. Should smoothing be done after defining response variable. This makes sense
    //sim_aug13_500_2_str3_   4654478
2. Should smoothing be done ONLY for screening but not prediction? This might make sense
  sim_aug13_500_3_str3_  4777365
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug13_500_str3_pms90_smooth.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug13_500_2_str3_pms90_smooth.csv")
# res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)

# Define custom color palette
# custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
#                    "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
#                    "Smooth_Ridge" = "#FFFF33", "PMS" = "#A65628", 
#                    "PMS_holp" = "#F781BF", "PMS_boots" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),]))
# resdat <- as.data.frame(rbind(res[1:3,]))
num.vox.vec <- (1:20)*100
colnames(resdat) <- num.vox.vec
# resdat$row_id <- c('PCA 90','PCA 90 mu','SPCA 90','SPCA 90 mu','Ridge', 'Smooth_PCA 90', 'Smooth_PCA 90 mu','Smooth_SPCA 90','Smooth_SPCA 90 mu','Smooth_Ridge')
resdat$row_id <- c('PCA 90 Smooth','SPCA 90 Smooth','Ridge Smooth','PCA 90 Smooth2','SPCA 90 Smooth2','Ridge Smooth2')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 2000, 500)) +
  # scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),]))
# resdat <- as.data.frame(rbind(res[4:6,]))

colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90 Smooth','SPCA 90 Smooth','Ridge Smooth','PCA 90 Smooth2','SPCA 90 Smooth2','Ridge Smooth2')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 2000, 500)) +
  # scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug13_500_str3_pms90.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug13_500_3_str3_pms90_smooth.csv")
# res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)

# Define custom color palette
# custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
#                    "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
#                    "Smooth_Ridge" = "#FFFF33", "PMS" = "#A65628", 
#                    "PMS_holp" = "#F781BF", "PMS_boots" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),]))
# resdat <- as.data.frame(rbind(res[1:3,]))
num.vox.vec <- (1:20)*100
colnames(resdat) <- num.vox.vec
# resdat$row_id <- c('PCA 90','PCA 90 mu','SPCA 90','SPCA 90 mu','Ridge', 'Smooth_PCA 90', 'Smooth_PCA 90 mu','Smooth_SPCA 90','Smooth_SPCA 90 mu','Smooth_Ridge')
resdat$row_id <- c('PCA 90','SPCA 90','Ridge','PCA 90 Smooth3','SPCA 90 Smooth3','Ridge Smooth3')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 2000, 500)) +
  # scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),]))
# resdat <- as.data.frame(rbind(res[4:6,]))

colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge','PCA 90 Smooth','SPCA 90 Smooth','Ridge Smooth')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 2000, 500)) +
  # scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
SPCA 90 smooth3 is good

I will re-run all the simulation results but with 4k voxels and viz

//sim_aug14_500_3_str smooth 4852824
//sim_aug14_500_str 4903912
//sim_aug14_500_2_str smooth 4903911
sim_aug14_500_str nbpms 4904081
Currently the viz of 2-3 smooths are the same.... they SHOULD be the same. Only difference is theta from cross-validation

#15 Aug

##Simulation results

```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug14_500_str3_pms90.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug14_500_2_str3_pms90_smooth.csv")
# res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- (read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug14_500_3_str3_pms90_smooth.csv"))
# res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
                   "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
                   "Smooth_Ridge" = "#FFFF33", "3 Smooth_PCA 90" = "#A65628", 
                   "3 Smooth_SPCA 90" = "#F781BF", "3 Smooth_Ridge" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[1:3,], res3[1:3, ]))
num.vox.vec <- (1:40)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge', '3 Smooth_PCA 90','3 Smooth_SPCA 90','3 Smooth_Ridge')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[4:6, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge', '3 Smooth_PCA 90','3 Smooth_SPCA 90','3 Smooth_Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```


##with pms

```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug14_500_str3_pms90.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug14_500_str3_nbpms.csv")
# res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- (read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug14_500_3_str3_pms90_smooth.csv"))
# res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
                   "PMS" = "#984EA3", "HOLP" = "#FF7F00",
                   "PMS_rob" = "#FFFF33", "3 Smooth_PCA 90" = "#A65628", 
                   "3 Smooth_SPCA 90" = "#F781BF", "3 Smooth_Ridge" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[1:3,], res3[1:3, ]))
num.vox.vec <- (1:40)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'PMS','HOLP','PMS_rob', '3 Smooth_PCA 90','3 Smooth_SPCA 90','3 Smooth_Ridge')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[4:6, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'PMS','HOLP','PMS_rob', '3 Smooth_PCA 90','3 Smooth_SPCA 90','3 Smooth_Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  ylim(20,75) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
## For 2nd Simulation Disjoint signal areas. 
I will use area 4 (centre-left) and 19 (bottom-right)
Everything is stored in `sim_dbmask.R` 
//... aug15_500_dbmask* 4911635

```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)
# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug15_500_dbmask_str3_pms90.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug15_500_dbmask_str3_nbpms.csv")
# res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- (read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug15_500_dbmask_3_str3_pms90_smooth.csv"))
# res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
                   "PMS" = "#984EA3", "HOLP" = "#FF7F00",
                   "PMS_rob" = "#FFFF33", "3 Smooth_PCA 90" = "#A65628", 
                   "3 Smooth_SPCA 90" = "#F781BF", "3 Smooth_Ridge" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[1:3,], res3[1:3, ]))
num.vox.vec <- (1:40)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'PMS','HOLP','PMS_rob', '3 Smooth_PCA 90','3 Smooth_SPCA 90','3 Smooth_Ridge')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[4:6, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'PMS','HOLP','PMS_rob', '3 Smooth_PCA 90','3 Smooth_SPCA 90','3 Smooth_Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  ylim(20,75) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
For this one, smoothing made everything worse
SPCA, PCA then PMS were the best respectively

But looking at viz, somehow HOLP and PMS did get all screening right.

***I think what to assess in Simulation is NOT predictive accuracy, but rather the selection.

##For 3rd Simulation: Gaussian blob
```{r}
library(oro.nifti)  # Ensure you have the oro.nifti package installed to handle NIfTI files

for(signal_strength in c(0,0.5,1,2,3,5)){

# Step 1: Load the mask and combine regions 4 and 15
res3_mask <- oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz')

combined_region <- (res3_mask == 4) | (res3_mask == 15)

# Step 2: Calculate the center of mass for the combined region
region_coords <- which(combined_region, arr.ind = TRUE)
center_of_mass <- colMeans(region_coords)

# Step 3: Generate the Gaussian blob centered at the center_of_mass
# Define the standard deviation (spread) of the Gaussian
sigma <- 10  # Adjust this value based on the size of your ROI
# signal_strength <- 3  # Define a scaling factor to increase the signal strength

# Create a 3D array to hold the Gaussian blob
gaussian_blob <- array(0, dim = dim(res3_mask))

# Populate the Gaussian blob
for (i in 1:nrow(region_coords)) {
  coord <- region_coords[i, ]
  distance_sq <- sum((coord - center_of_mass)^2)
  gaussian_blob[coord[1], coord[2], coord[3]] <- signal_strength *exp(-distance_sq*10 / (2 * sigma^2))
}

# Step 4: Apply the Gaussian blob to the combined region
signal_mask <- combined_region * gaussian_blob

# Optional: Add the signal to the original mask or save it
res3_mask <- res3_mask * 0  # Start with a blank mask
res3_mask[combined_region] <- signal_mask[combined_region]

res3_mask@datatype = 16
res3_mask@bitpix = 32
writeNIfTI(res3_mask,paste0("/well/nichols/users/qcv214/pms2/viz/sim/res3_4n15_signal",signal_strength,"_gaussian_blob.nii.gz"))
}
```

This current implementation looks good, according to visualisation. 

Everything is stored in `sim_gaussmask.R` 
//... aug15_500_gaussmask* 4912481 ==> I think it's wrong. The addition of signal seems wrong. I will correct in `sim_gaussmask2.R`

###Correction
I have decided to generate a visualisation of voxel ranking with image files `_rank_`, saved in 

sim_binmask2.R. 4916105
sim_dbmask2.R. 4921442
sim_gaussmask2.R 4912985

###Gaussian blob
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)
# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug15_500_gaussmask_str3_pms90.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug15_500_gaussmask_str3_nbpms.csv")
# res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- (read.csv("/well/nichols/users/qcv214/pms2/pile/sim_aug15_500_gaussmask_3_str3_pms90_smooth.csv"))
# res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
                   "PMS" = "#984EA3", "HOLP" = "#FF7F00",
                   "PMS_rob" = "#FFFF33", "3 Smooth_PCA 90" = "#A65628", 
                   "3 Smooth_SPCA 90" = "#F781BF", "3 Smooth_Ridge" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[1:3,], res3[1:3, ]))
num.vox.vec <- (1:40)*100
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'PMS','HOLP','PMS_rob', '3 Smooth_PCA 90','3 Smooth_SPCA 90','3 Smooth_Ridge')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[4:6, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'PMS','HOLP','PMS_rob', '3 Smooth_PCA 90','3 Smooth_SPCA 90','3 Smooth_Ridge')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  ylim(20,75) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

PMS and SPCA 90 are the best methods, need to judge from viz, but I bet PMS is better

#17 Aug

##4th simulation method: sparse
One other test method is to induce a random signal at every 10th
`sim_sparsemask2.R`  5766633 =>aug15
##Result analysis


(non-predictive) Metrics:

- `True % overlap = (TP)/(TP+FN)`
- `FPR = FP/(FP+TN)`. false positive rate (FPR) is the number of people who do not have the disease but are identified as having the disease (all FPs), divided by the total number of people who do not have the disease (includes all FPs and TNs).
    => note that our context is not voxel significance, but rather ranking, so FPR might not be needed
- `FDR = FP/(FP+TP)`.  false discovery rate (FDR) is the number of people who do not have the disease but are identified as having the disease (all FPs), divided by the total number of people who are identified as having the disease (includes all FPs and TPs).
- `ROC, AUC`?

1. Sensitivity => varying signal strength and evaluate the metrics, we can plot the graph for each method.
  Problem is we have too many methods and 3 metrics

2. Stability => either 1) use different subset of training, but our sample is already small. or 2) add random noise into some subjects 
  => I think these are two separate problems. 1) assess using smaller sample sizes, 2) assess nosiy data
  => for 1), we can do bootstrapping (sampling with replacement) which is valid
     for 2), we can do Noise simulation (varying strength of noise 0%, 5%, 10%) to assess robustness
   

###Sensitivity
1. Signal = 1, signal = 0.5, signal = 0

all is aug17
//`sim_gaussmask_sens.R` 5935510
//`sim_dbmask_sens.R` 5935504
//`sim_binmask_sens.R` 5935538    
//`sim_sparsemask_sens.R` 5935519

####Evaluation
```{r}
accuracy_cal <- function(rank.vec, mask.signal) {
  # Determine the number of top indices to consider
  n <- length(mask.signal)
  
  # Take the top n indices from rank.vec
  top_n <- rank.vec[1:n]
  
  # Compute True Positives (TP)
  TP <- length(intersect(top_n, mask.signal))
  
  # Compute Overlap as the percentage of true positives
  overlap <- round(TP * 100 / n, 3)
  
  # Compute False Positives (FP)
  FP <- length(setdiff(top_n, mask.signal))
  
  # Compute False Negatives (FN)
  FN <- length(setdiff(mask.signal, top_n))
  
  # Compute False Positive Rate (FPR)
  total_non_signal <- length(rank.vec) - n
  FPR <- round(FP*100 / total_non_signal, 3)
  
  # Compute False Discovery Rate (FDR)
  FDR <- round(FP*100 / (FP + TP), 3)
  
  # Return the results as a named list
  return(list(
    overlap = overlap,
    FPR = FPR,
    FDR = FDR
  ))
}

```

#####Test
```{r}
#Binmask
rank.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug17_500_binmask_3_rank_str3_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.index <- (mask.vec %in% c(4,15))
mask.signal <- which(mask.index)

accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

#dbmask
rank.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug17_500_dbmask_3_rank_str3_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.index <- (mask.vec %in% c(4,19))
mask.signal <- which(mask.index)

accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

#Gauss

rank.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug17_500_gaussmask_3_rank_str3_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.index <- (mask.vec %in% c(4,15))
mask.signal <- which(mask.index)

accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

#sparse mask
rank.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug17_500_sparsemask_3_rank_str3_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.signal <- seq(1,length(rank.vec), 10) #signal every 10th voxel

accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

#
```

I want this but for 

```{r}
# Define the parameters
signal_types <- c("binmask", "dbmask", "gaussmask", "sparsemask")
methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp")
signal_strengths <- c(5,3,2, 1, 0.5, 0)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/aug17_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)
```

```{r}
for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }

      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")

      # Load the rank vector
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

HOLP is always the best method with 100% recovery at high signal in all cases apart from Gaussian blob, followed by PMs
But PMS is the best in Gaussian blob

Our new methods are significantly inferior to PMS and HOLP

```{r}

# Optionally, plot the results using ggplot2
library(ggplot2)

# Example plot: Overlap vs. Signal Strength for each method and signal type
ggplot(results, aes(x = SignalStrength, y = Overlap, color = Method)) +
  geom_line() +
  facet_wrap(~ SignalType) +
  theme_minimal() +
  labs(title = "True % Overlap vs Signal Strength",
       x = "Signal Strength",
       y = "True % Overlap")
```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("True % Overlap vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "True % Overlap",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```

I want to do line plots for each mask

Recall, Gaussian Blob is wrong. for varying signal
Correting Gauss signal, with peak at 0,0.5,1,2,3,5 `7210345`

Adding signal 2,5 to the current analyses

###Stability

1) bootstrapping: I think it is quite uninteresting, but needed
    sample(1:250,500,replace = TRUE)
    
2) Adding noise. will it really be different from 0-strength signal?


Splitting training data into 2 sets, evaluate all methods with strength 0, 0.5,3
//sim_binmask_stab.R. 7210843

#20 Aug

Right now I only have 2 subsets of data for stability. Computing sd is not an option, so I will just calculate the difference between two subsets instead.

```{r}
# Define the parameters
signal_types <- c("binmask")
methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp")
signal_strengths <- c(3, 0.5, 0)
sets <- c(1, 2)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/aug20_stability_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Metric = character(),
  AbsoluteDifference = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }
      
      # Initialize vectors to store metrics for each set
      metrics_set1 <- NULL
      metrics_set2 <- NULL
      
      for (e in sets) {
        # Construct the file path for each set
        file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_set", e, "_", b, ".nii.gz")
        
        # Load the rank vector
        rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))

        # Define the mask.signal based on signal type
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)

        # Compute accuracy metrics
        metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

        # Store the metrics for each set
        if (e == 1) {
          metrics_set1 <- metrics
        } else {
          metrics_set2 <- metrics
        }
      }
      
      # Compute absolute differences between set 1 and set 2
      abs_diff_overlap <- abs(metrics_set1$overlap - metrics_set2$overlap)
      abs_diff_FPR <- abs(metrics_set1$FPR - metrics_set2$FPR)
      abs_diff_FDR <- abs(metrics_set1$FDR - metrics_set2$FDR)
      
      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Metric = "Overlap",
        AbsoluteDifference = abs_diff_overlap
      ))
      
      # results <- rbind(results, data.frame(
      #   SignalType = a,
      #   Method = b,
      #   SignalStrength = c,
      #   Metric = "FPR",
      #   AbsoluteDifference = abs_diff_FPR
      # ))
      # 
      # results <- rbind(results, data.frame(
      #   SignalType = a,
      #   Method = b,
      #   SignalStrength = c,
      #   Metric = "FDR",
      #   AbsoluteDifference = abs_diff_FDR
      # ))
    }
  }
}
```
```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot for each metric
for (signal_type in signal_types) {
  for (metric in unique(results$Metric)) {
    # Filter the results for the current SignalType and Metric
    signal_data <- subset(results, SignalType == signal_type & Metric == metric)
    
    # Create the plot with bolder lines and distinct colors
    p <- ggplot(signal_data, aes(x = SignalStrength, y = AbsoluteDifference, color = Method)) +
      geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
      scale_color_manual(values = custom_colors) +  # Use custom colors
      theme_minimal() +
      labs(title = paste(metric, "Absolute Difference vs Signal Strength -", signal_type),
           x = "Signal Strength",
           y = paste(metric, "Absolute Difference"),
           color = "Method") +
      theme(
        plot.title = element_text(size = 14, face = "bold"),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10)
      )
    
    # Display the plot
    print(p)
  }
}
```


#21 Aug
Real-data simulation signal

// `sim_age_create_signal_SPCA_smooth.R`. 7865474
'/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth'

Use SPCA smooth on age prediction, then select top 1600 voxels to create a flat signal
//`sim_SPCAmask_sens.R` 7866676 => this is label aug17

#23 Aug

##Plotting SPCAmask

```{r}
# Define the parameters
signal_types <- c("SPCAmask")
methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp")
signal_strengths <- c(0,0.5,1,2,3,5)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/aug17_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }

      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")

      # Load the rank vector
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "SPCAmask") {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      } 

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/SPCAmask_sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("True % Overlap vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "True % Overlap",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
How are HOLP and pms still better, and why is SPCA90_smooth so terrible. Is it because of the flat signal and linear sum? We have seen that HOLP doesn't do well in Gaussian blob. so instead of flat signal, let's do the sum of the coef.

sim_SPCAcoefmask_sens.R 8316108

sim_binmask_stab.R. 8316181 => aug23, but with 10 different subsets

#23 Aug

##Sensitivity
Lookad SPCA mask

```{r}
# Define the parameters
signal_types <- c("SPCAmask","SPCAcoefmask")
methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp")
signal_strengths <- c(0,0.5,1,2,3,5)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/aug17_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }

      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")

      # Load the rank vector
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      #if (a == "SPCAmask") {
      if (TRUE) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      } 

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/SPCAcoefmask_sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("True % Overlap vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "True % Overlap",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
Still doesn't work. 
HOLP and PMS are still better.
Idk what to do...


##Stability
```{r}
# Define the parameters
signal_types <- c("binmask")
methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp")
signal_strengths <- c(3, 0.5, 0)
sets <- 1:10 # Now handling 10 sets
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/aug23_stability_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Metric = character(),
  SD = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }
      
      # Initialize lists to store metrics for all 10 sets
      overlap_list <- numeric(length(sets))
      
      for (e in sets) {
        # Construct the file path for each set
        file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_set", e, "_", b, ".nii.gz")
        
        # Load the rank vector
        rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))

        # Define the mask.signal based on signal type
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)

        # Compute accuracy metrics
        metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

        # Store the metrics for each set
        overlap_list[e] <- metrics$overlap
      }
      
      # Compute the standard deviation of metrics across the 10 sets
      sd_overlap <- sd(overlap_list)
      
      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Metric = "Overlap",
        SD = sd_overlap
      ))

    }
  }
}
```
```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot for each metric
for (signal_type in signal_types) {
  for (metric in unique(results$Metric)) {
    # Filter the results for the current SignalType and Metric
    signal_data <- subset(results, SignalType == signal_type & Metric == metric)
    
    # Create the plot with bolder lines and distinct colors
    p <- ggplot(signal_data, aes(x = SignalStrength, y = SD, color = Method)) +
      geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
      scale_color_manual(values = custom_colors) +  # Use custom colors
      theme_minimal() +
      labs(title = paste(metric, "Standard Deviation vs Signal Strength -", signal_type),
           x = "Signal Strength",
           y = paste(metric, "Standard Deviation"),
           color = "Method") +
      theme(
        plot.title = element_text(size = 14, face = "bold"),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10)
      )
    
    # Display the plot
    print(p)
    
    # Save the plot to a file
    ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_", metric, "_stability_sd_plot.png"),
           plot = p, width = 8, height = 6)
  }
}
```
When signal is weak, SPCA_smooth is the best, whereas they all converge when signal is too strong.


##To do
Re-run and think about the real-data `LINE 2667`. to see if smoothing works

re-run cv_pms8090_full_smooth: 
`aug26_cv_pms8090_full_smooth`  8768496 exactly the same as july20 version, but just wanted to double check.
cv_pms8090_full_smooth2.R 8768503 ===> smoothing only applies for screening, but raw data for pred

#27 Aug
Real-data re-visit

aug26 smooth is still the same as july20 version

##Look ing at smoothing for screening
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/july22_cv_pms90_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug26_cv_pms8090_full_smooth2.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/july26_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
                   "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
                   "Smooth_Ridge" = "#FFFF33", "PMS" = "#A65628", 
                   "PMS_holp" = "#F781BF", "PMS_boots" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(2, 4, 5),], res3[1:3, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp','PMS_boots')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(7, 9, 10),], res3[4:6, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp','PMS_boots')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

if we were to apply smoothing ONLY for screening, smooth_ridge is the best,followed by smooth SPCA and smooth PCA.
Why are these so much better than PMS and HOLP

```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug26_cv_pms8090_full_smooth.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug26_cv_pms8090_full_smooth2.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/july26_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("Smooth_PCA 90" = "#E41A1C", "Smooth_SPCA 90" = "#377EB8", "Smooth_Ridge" = "#4DAF4A",
                   "Smooth2_PCA 90" = "#984EA3", "Smooth2_SPCA 90" = "#FF7F00",
                   "Smooth2_Ridge" = "#FFFF33", "PMS" = "#A65628", 
                   "PMS_holp" = "#F781BF", "PMS_boots" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[c(2, 4, 5),], res2[c(2, 4, 5),], res3[1:3, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge', 'Smooth2_PCA 90','Smooth2_SPCA 90','Smooth2_Ridge','PMS','PMS_holp','PMS_boots')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[c(7, 9, 10),], res2[c(7, 9, 10),], res3[4:6, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge', 'Smooth2_PCA 90','Smooth2_SPCA 90','Smooth2_Ridge','PMS','PMS_holp','PMS_boots')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

#27 August

Added Mass Uni Analysis.

I have noticed that my sensitivity and stability analysis were using wrong strength of signal. The current way of defining signal kept getting amplified due to the over-writing signals (e.g. add 2 to current signal of 1.)
the `SPCAcoef` and `Gaussian` and `sim_binmask_stab` were unaffected.

`aug27`  version for (and ADDED MUA called `pvalthresmap`)
//binmask 8789395
//dbmask 8789488
//sparsemask 8789407
//SPCAmask 8789436

##Defining metrics
```{r}
accuracy_cal <- function(rank.vec, mask.signal) {
  # Determine the number of top indices to consider
  n <- length(mask.signal)
  
  # Take the top n indices from rank.vec
  top_n <- rank.vec[1:n]
  
  # Compute True Positives (TP)
  TP <- length(intersect(top_n, mask.signal))
  
  # Compute Overlap as the percentage of true positives
  overlap <- round(TP * 100 / n, 3)
  
  # Compute False Positives (FP)
  FP <- length(setdiff(top_n, mask.signal))
  
  # Compute False Negatives (FN)
  FN <- length(setdiff(mask.signal, top_n))
  
  # Compute False Positive Rate (FPR)
  total_non_signal <- length(rank.vec) - n
  FPR <- round(FP*100 / total_non_signal, 3)
  
  # Compute False Discovery Rate (FDR)
  FDR <- round(FP*100 / (FP + TP), 3)
  
  # Return the results as a named list
  return(list(
    overlap = overlap,
    FPR = FPR,
    FDR = FDR
  ))
}
```

```{r}
# Define the parameters
# signal_types <- c("binmask", "dbmask", "gaussmask", "sparsemask")
signal_types <- c("binmask", "dbmask", "sparsemask","SPCAmask")

# signal_types <- c("SPCAmask")


methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp","pvalthresmap")
signal_strengths <- c(5,3,2, 1, 0.5, 0)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/aug27_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)
```

```{r}
for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }

      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")
      
      ####
      if(b == "pvalthresmap"){
        file_path <- paste0(base_path, a, "_", d, "str", c, "_", b, ".nii.gz")
      }
      ####

      # Load the rank vector
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask") {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "pvalthresmap" = "#466791"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("True % Overlap vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "True % Overlap",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
I need to look at the p-value map
I think p-value is not directly comparable to the other methods. Other methods are rank-based, whereas p-value is not ranked.

###Plotting FPR
```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "pvalthresmap" = "#466791"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = FPR, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,15) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("FPR vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "FPR",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
I think exact same ranking as True Overlap


#29 Aug

##Real data
Correcting real-data smooth2: smoothing for screening but not prediction
aug29 smooth2 9191206 ==> no PCA 80 or SPCA 80

`cv_pm_pms_full.R` => aug29_pm... conduct all screening methods on pm_tf variable taken from kgpnn/cog.
aug29_pm... 9191132

#30 Aug

## Smooth 2 on real-data age
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug26_cv_pms8090_full_smooth.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug29_cv_pms8090_full_smooth2.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/july26_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("Smooth_PCA 90" = "#E41A1C", "Smooth_SPCA 90" = "#377EB8", "Smooth_Ridge" = "#4DAF4A",
                   "Smooth2_PCA 90" = "#984EA3", "Smooth2_SPCA 90" = "#FF7F00",
                   "Smooth2_Ridge" = "#FFFF33", "PMS" = "#A65628", 
                   "PMS_holp" = "#F781BF", "PMS_boots" = "#999999")

# First plot
resdat <- as.data.frame(rbind(res[c(2, 4, 5),], res2[c(1:3),], res3[1:3, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge', 'Smooth2_PCA 90','Smooth2_SPCA 90','Smooth2_Ridge','PMS','PMS_holp','PMS_boots')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[c(7, 9, 10),], res2[c(4:6),], res3[4:6, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge', 'Smooth2_PCA 90','Smooth2_SPCA 90','Smooth2_Ridge','PMS','PMS_holp','PMS_boots')
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Smooth data + SPCA is still the best.

##Plotting predicting pm_transformed
Ignore smooth 2
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug29_pm_cv_pms8090_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug29_pm_cv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug29_pm_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
                   "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
                   "Smooth_Ridge" = "#FFFF33", "PMS" = "#A65628", 
                   "PMS_holp" = "#F781BF")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),], res3[1:2, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[3:4, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
For this version. PCA is good, smoothing made everying worse

I forgot to save Ridge result for non-smooth!!! Let's re-run
9273257

##To do
Let's go back to double cross-validation method.
. It turns out that my ridge regression has not been properly cross-validated. Need to re-run everything again with it fixed.

**first off, my notation for smooth 2 is flipped between simulation and real-data. In simulation, smooth 2 is smoothing + screening then predict on smooth.

[got oom] `dcv_pm_pms_full` 9284803 and ===> only smooth was saved, otherwise I need to run all types separately.
[got oom] `dcv_age_pms_full` 9284772 ===> only smooth was saved, otherwise I need to run all types separately.
All save into aug30_ ... _ dcv

still need to re-run for simulation tho.
Actually if we think about it. The applying smooth first to the data, then do signal recovery, it doesn't make so much sense idk. because it also smoothes out the signal no inactive regions.

###Simulation
All with aug30
binmask 9286659
dbmask 9286797
sparsemask 9286823
SPCAmask  9286744
gaussmask 9286694
binmask stab 9286857


#2 sep

For the OOM real-data, I have created 2 new files for age and pm that only eval non-smooth and pms
called 
`dcv_age_pms_full_raw_pms` 9589755
`dcv_pm_pms_full_raw_pms` 9589753

##Real-data
Note the new subset of data (same as kgpnn) and double cv

###age
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
                   "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
                   "Smooth_Ridge" = "#FFFF33", "PMS" = "#A65628", 
                   "PMS_holp" = "#F781BF")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),], res3[1:2, ]))

num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[3:4, ]))

colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Here we see that ridge regression are back to being the beset again.
FOllowed by SPCA, smooth Ridge, then Smooth SPCA

```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
                   "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
                   "Smooth_Ridge" = "#FFFF33", "PMS" = "#A65628", 
                   "PMS_holp" = "#F781BF")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),], res3[1:2, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[3:4, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

###pm
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_pms8090_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)

# Define custom color palette
custom_colors <- c("PCA 90" = "#E41A1C", "SPCA 90" = "#377EB8", "Ridge" = "#4DAF4A",
                   "Smooth_PCA 90" = "#984EA3", "Smooth_SPCA 90" = "#FF7F00",
                   "Smooth_Ridge" = "#FFFF33", "PMS" = "#A65628", 
                   "PMS_holp" = "#F781BF")

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),], res3[1:2, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[3:4, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Smooth ridge is still the best. SPCA and PCA are worse.

###Simulation with double cv

#note that result for MUA is wrong 

###Add MUA argument
```{r}
accuracy_cal <- function(rank.vec, mask.signal, mua = FALSE) {
  # Determine the number of top indices to consider
  n <- length(mask.signal)
  
  # Take the top n indices from rank.vec
  
  if(mua){
    top_n <- rank.vec
    } else {
  top_n <- rank.vec[1:n]
    }
  # Compute True Positives (TP)
  TP <- length(intersect(top_n, mask.signal))
  
  # Compute Overlap as the percentage of true positives
  overlap <- round(TP * 100 / n, 3)
  
  # Compute False Positives (FP)
  FP <- length(setdiff(top_n, mask.signal))
  
  # Compute False Negatives (FN)
  FN <- length(setdiff(mask.signal, top_n))
  
  # Compute False Positive Rate (FPR)
  total_non_signal <- length(rank.vec) - n
  FPR <- round(FP*100 / total_non_signal, 3)
  
  # Compute False Discovery Rate (FDR)
  FDR <- round(FP*100 / (FP + TP), 3)
  
  # Return the results as a named list
  return(list(
    overlap = overlap,
    FPR = FPR,
    FDR = FDR
  ))
}
```

```{r}
# Define the parameters
# signal_types <- c("binmask", "dbmask", "gaussmask", "sparsemask")
signal_types <- c("binmask", "dbmask","gaussmask", "sparsemask","SPCAmask","SPCAcoefmask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp","pvalthresmap")
signal_strengths <- c(5,3,2, 1, 0.5, 0)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/aug30_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)
```

```{r}
for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }

      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")
      
      ####
      is.mua <- (b == "pvalthresmap")
      
      if(b == "pvalthresmap"){
        file_path <- paste0(base_path, a, "_", d, "str", c, "_", b, ".nii.gz")
      }
      ####
      
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      
      # if MUA
      if(b == "pvalthresmap"){
        # rank.vec <- rank.vec[rank.vec > 0]
        zero.p <- which(rank.vec == 0)
      }
      
      rank.vec <- order(rank.vec, decreasing = TRUE)
      
      # if MUA
      if(b == "pvalthresmap"){
        # rank.vec <- rank.vec[rank.vec > 0]
        rank.vec <- setdiff(rank.vec,zero.p)
      }
      
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask" || a == "SPCAcoefmask" ) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal,mua = is.mua)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "pvalthresmap" = "#466791"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("True % Overlap vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "True % Overlap",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
#####FPR
```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "pvalthresmap" = "#466791"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = FPR, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("FPR vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "FPR",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
}
```

####Stability
```{r}
# Define the parameters
signal_types <- c("binmask")
methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp")
signal_strengths <- c(3, 0.5, 0)
sets <- 1:10 # Now handling 10 sets
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/aug30_stability_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Metric = character(),
  SD = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }
      
      # Initialize lists to store metrics for all 10 sets
      overlap_list <- numeric(length(sets))
      
      for (e in sets) {
        # Construct the file path for each set
        file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_set", e, "_", b, ".nii.gz")
        
        # Load the rank vector
        rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))

        # Define the mask.signal based on signal type
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)

        # Compute accuracy metrics
        metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

        # Store the metrics for each set
        overlap_list[e] <- metrics$overlap
      }
      
      # Compute the standard deviation of metrics across the 10 sets
      sd_overlap <- sd(overlap_list)
      
      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Metric = "Overlap",
        SD = sd_overlap
      ))

    }
  }
}
```
```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot for each metric
for (signal_type in signal_types) {
  for (metric in unique(results$Metric)) {
    # Filter the results for the current SignalType and Metric
    signal_data <- subset(results, SignalType == signal_type & Metric == metric)
    
    # Create the plot with bolder lines and distinct colors
    p <- ggplot(signal_data, aes(x = SignalStrength, y = SD, color = Method)) +
      geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
      scale_color_manual(values = custom_colors) +  # Use custom colors
      theme_minimal() +
      labs(title = paste(metric, "Standard Deviation vs Signal Strength -", signal_type),
           x = "Signal Strength",
           y = paste(metric, "Standard Deviation"),
           color = "Method") +
      theme(
        plot.title = element_text(size = 14, face = "bold"),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10)
      )
    
    # Display the plot
    print(p)
    
    # Save the plot to a file
    ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_", metric, "_stability_sd_plot.png"),
           plot = p, width = 8, height = 6)
  }
}
```

So now PMS, HOLP are the best????

##To do
I should try replicating HOLP with my own computation to see if something is fundamentally wrong

I will first do this on smooth SPCA mask
`sim_SPCAmask_sens_pseudo.R`
//aug30... _pseuholp 9590140

Running a new SPCAcoefmask
//aug30_500_SPCAcoefmask_str 9590288

###Assessing pseudo-holp
```{r}
# Define the parameters
# signal_types <- c("binmask", "dbmask", "gaussmask", "sparsemask")
signal_types <- c("SPCAmask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp","pseuholp")
signal_strengths <- c(5,3,2, 1, 0.5, 0)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/aug30_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }

      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")
      
      ####
      is.mua <- (b == "pvalthresmap")
      
      if(b == "pvalthresmap"){
        file_path <- paste0(base_path, a, "_", d, "str", c, "_", b, ".nii.gz")
      }
      ####
      
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      
      # if MUA
      if(b == "pvalthresmap"){
        # rank.vec <- rank.vec[rank.vec > 0]
        zero.p <- which(rank.vec == 0)
      }
      
      rank.vec <- order(rank.vec, decreasing = TRUE)
      
      # if MUA
      if(b == "pvalthresmap"){
        # rank.vec <- rank.vec[rank.vec > 0]
        rank.vec <- setdiff(rank.vec,zero.p)
      }
      
      # Define the mask.signal based on signal type
      if (a == "SPCAmask") {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal,mua = is.mua)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "pseuholp" = "#466791"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("True % Overlap vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "True % Overlap",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
}
```
Okay, HOLP and pseudo holp are the same.


#2 sep

For simulation, I need to add random noise to the signal, otherwise everyone will have the same response ==> adding N(0,0.1)
I have changed pval to tmap and `rank tmap`
all `2 sep`
//`sim_gaussmask_sens2.R` 9664878
//`sim_dbmask_sens2.R`  9669662
//`sim_binmask_sens2.R`     9665326
//`sim_sparsemask_sens2.R` 9665042
//`sim_SPCAmask_sens2.R`  9665083

#3 Sep
Re-define signals, re-define MUA

**note that I wrongly saved my tmap to the name _2_rank
```{r}
accuracy_cal <- function(rank.vec, mask.signal) {
  # Determine the number of top indices to consider
  n <- length(mask.signal)
  
  # Take the top n indices from rank.vec
  top_n <- rank.vec[1:n]
    
  # Compute True Positives (TP)
  TP <- length(intersect(top_n, mask.signal))
  
  # Compute Overlap as the percentage of true positives
  overlap <- round(TP * 100 / n, 3)
  
  # Compute False Positives (FP)
  FP <- length(setdiff(top_n, mask.signal))
  
  # Compute False Negatives (FN)
  FN <- length(setdiff(mask.signal, top_n))
  
  # Compute False Positive Rate (FPR)
  total_non_signal <- length(rank.vec) - n
  FPR <- round(FP*100 / total_non_signal, 3)
  
  # Compute False Discovery Rate (FDR)
  FDR <- round(FP*100 / (FP + TP), 3)
  
  # Return the results as a named list
  return(list(
    overlap = overlap,
    FPR = FPR,
    FDR = FDR
  ))
}
```

```{r}
# Define the parameters
signal_types <- c("binmask", "dbmask","gaussmask", "sparsemask","SPCAmask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp","tmap")
signal_strengths <- c(5,3,2, 1, 0.5)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep2_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)
```

```{r}
for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else if (grepl("tmap$", b)) {
        d <- "2_"
      } else {
        d <- ""
      }

      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask" || a == "SPCAcoefmask" ) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("True % Overlap vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "True % Overlap",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```

*I need to go back and check all the signal plot for these!!



##To do
Run stability with MUA

`sim_binmask_stab2.R`
//sep3  9687386

Also, I have changed the definition of sensitivity. I am now fixing all noise to the same across all, before adding signals.
sep3
//`sim_gaussmask_sens2.R`  9688139
//`sim_dbmask_sens2.R`    9688401
//`sim_binmask_sens2.R`     9688396
//`sim_sparsemask_sens2.R`  9688406
//`sim_SPCAmask_sens2.R`   9688411

```{r}
# Define the parameters
signal_types <- c("binmask", "dbmask","gaussmask", "sparsemask","SPCAmask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp","tmap")
signal_strengths <- c(5,3,2, 1, 0.5,0)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep3_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)
```

```{r}
for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else if (grepl("tmap$", b)) {
        d <- "2_"
      } else {
        d <- ""
      }

      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask" || a == "SPCAcoefmask" ) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("True % Overlap vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "True % Overlap",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```

####Stability
```{r}
# Define the parameters
signal_types <- c("binmask")
methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp","tmap")
signal_strengths <- c(0,0.5,1,2,3,5)
sets <- 1:10 # Now handling 10 sets
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep3_stability_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Metric = character(),
  SD = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }
      
      # Initialize lists to store metrics for all 10 sets
      overlap_list <- numeric(length(sets))
      
      for (e in sets) {
        # Construct the file path for each set
        file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_set", e, "_", b, ".nii.gz")
        
        # Load the rank vector
        rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))

        # Define the mask.signal based on signal type
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)

        # Compute accuracy metrics
        metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

        # Store the metrics for each set
        overlap_list[e] <- metrics$overlap
      }
      
      # Compute the standard deviation of metrics across the 10 sets
      sd_overlap <- sd(overlap_list)
      
      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Metric = "Overlap",
        SD = sd_overlap
      ))

    }
  }
}
```
```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot for each metric
for (signal_type in signal_types) {
  for (metric in unique(results$Metric)) {
    # Filter the results for the current SignalType and Metric
    signal_data <- subset(results, SignalType == signal_type & Metric == metric)
    
    # Create the plot with bolder lines and distinct colors
    p <- ggplot(signal_data, aes(x = SignalStrength, y = SD, color = Method)) +
      geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
      scale_color_manual(values = custom_colors) +  # Use custom colors
      theme_minimal() +
      labs(title = paste(metric, "Standard Deviation vs Signal Strength -", signal_type),
           x = "Signal Strength",
           y = paste(metric, "Standard Deviation"),
           color = "Method") +
      theme(
        plot.title = element_text(size = 14, face = "bold"),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10)
      )
    
    # Display the plot
    print(p)
    
    # Save the plot to a file
    ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_", metric, "_stability_sd_plot.png"),
           plot = p, width = 8, height = 6)
  }
}
```
Look at shrinkage
`sim_binmask_shrinkage_test.R` `9736077`
sep3..binmask...PCA_smooth and SPCA_smooth _4_ and _5_ with str0, 0.5, 3
sim_binmask_shrinkage_covcor_test.R `9736124` using Cov and Corr approx rather than proj matrix ==> _6_ and _7_ for cov, and _8_ for corr

##Shrinkage

```{r}
# Define the parameters
signal_types <- c("binmask")

methods <- c("PCA90_smooth", "SPCA90_smooth","holp")
signal_strengths <- c(3, 0.5,0)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep3_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      for(d in 3:8){
        d <- paste0(d,"_")
        if (grepl("holp$", b)){
          d <- ""
        }
        
        # print(d)
      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } 

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = paste0(b,"_",d),
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
      }
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)
library(dplyr)

# Create the renaming map
method_rename_map <- c(
  "PCA90_smooth_3_" = "PCA_original",
  "PCA90_smooth_4_" = "PCA_Adapt_Shrink",
  "PCA90_smooth_5_" = "PCA_Fixed_Shrink",
  "PCA90_smooth_6_" = "PCA_Covariance_Adapt_Shrink",
  "PCA90_smooth_7_" = "PCA_Covariance_Fixed_Shrink",
  "PCA90_smooth_8_" = "PCA_Correlation_Fixed_Shrink",
  "SPCA90_smooth_3_" = "SPCA_original",
  "SPCA90_smooth_4_" = "SPCA_Adapt_Shrink",
  "SPCA90_smooth_5_" = "SPCA_Fixed_Shrink",
  "SPCA90_smooth_6_" = "SPCA_Covariance_Adapt_Shrink",
  "SPCA90_smooth_7_" = "SPCA_Covariance_Fixed_Shrink",
  "SPCA90_smooth_8_" = "SPCA_Correlation_Fixed_Shrink",
  "holp_" = "HOLP"
)

# Apply the renaming to the 'Method' column in your dataframe
results <- results %>%
  mutate(Method = recode(Method, !!!method_rename_map))


# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA_original" = "#006d2c",  # Dark green
  "PCA_Adapt_Shrink" = "#33a02c",  # Green
  "PCA_Fixed_Shrink" = "#66c2a5",  # Light green
  "PCA_Covariance_Adapt_Shrink" = "#99d8c9",  # Pale green
  "PCA_Covariance_Fixed_Shrink" = "#ccece6",  # Very light green
  "PCA_Correlation_Fixed_Shrink" = "#238b45",  # Darker green
  
  "SPCA_original" = "#e31a1c",  # Dark red
  "SPCA_Adapt_Shrink" = "#b2182b",  # Deep red-purple
  "SPCA_Fixed_Shrink" = "#fb9a99",  # Light red-pink
  "SPCA_Covariance_Adapt_Shrink" = "#fc9272",  # Light coral-red
  "SPCA_Covariance_Fixed_Shrink" = "#fcbba1",  # Pale pink-red
  "SPCA_Correlation_Fixed_Shrink" = "#fd8d3c",   # Soft reddish-orange
  
  "HOLP" = '#000000'  # Black
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("True % Overlap vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "True % Overlap",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
}
```

#5 sep
Based on the visualisation, I will stick with the covariance with fixed shrinkage for simplicity.
Let's try both projection and covariance
Re-run real-data analysis
//`dcv_age_pms_full_shrink.R` sep5_ shrink, viz:cov and proj   proj 9874306=> 
//`dcv_pm_pms_full_shrink.R` sep5_ shrink, viz:cov and proj 9876338 ===> OOM during cov... removing variables



## New signal
I have created new synthetic data with strong inter-subject variability
`sim_binmask_sens3.R`
sep5_ 9821631

[failed] dcv_pm_pms_full_shrink.R 9833946, testing original with 50 subjects ==> confirms that original works fine
[failed] dcv_pm_pms_full_shrink.R 9836789, testing more efficient way with 50 subjects ==> still failed

9847375 => should work now

##Plotting simulation
New method




```{r}
# Define the parameters
signal_types <- c("binmask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp","tmap")
signal_strengths <- c(5,3,2, 1, 0.5,0)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep5_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }

      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask" || a == "SPCAcoefmask" ) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791"
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("True % Overlap vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "True % Overlap",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```

#6 Sep
New simulation set up with varying signal:

```{r}

```



//`sim_gaussmask_sens3.R`   9948002
[failed] //`sim_dbmask_sens3.R`    9948570 error
[failed] //`sim_binmask_sens3.R`     9948308 error 
[failed] //`sim_sparsemask_sens3.R`  9948474 error
[failed] //`sim_SPCAmask_sens3.R`   9948510 error in diag(pca$sdev)

==> I think the algorithm fail when signal is too strong, let's look at it again. Strong signal causse pca to detect like 1 component with 90%

#7 sep

##Re-run of real-data with shrinkage

###Age
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)
res4 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep5_age_dcv_pms90_smooth_shrink.csv")
res4 <-  cbind(res4, matrix(data=NA, nrow=nrow(res4), ncol = (length(res) - length(res4))))
colnames(res4) <- colnames(res)

# Define custom color palette
custom_colors <- c(
  "PCA 90" = "#E41A1C",        # Red
  "SPCA 90" = "#377EB8",       # Blue
  "Ridge" = "#4DAF4A",         # Green
  "Smooth_PCA 90" = "#984EA3", # Purple
  "Smooth_SPCA 90" = "#FF7F00",# Orange
  "Smooth_Ridge" = "#FFFF33",  # Yellow
  "PMS" = "#A65628",           # Brown
  "PMS_holp" = "#F781BF",      # Pink
  "SmoothPCA_Proj" = "#8DD3C7",  # Light teal
  "SmoothSPCA_Proj" = "#B3DE69", # Light green
  "SmoothPCA_Cov" = "#FDB462",   # Orange-yellow
  "SmoothSPCA_Cov" = "#FB8072"   # Salmon pink
)

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),], res3[1:2, ], res4[1:4, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[3:4, ], res4[5:8, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

Ridge => SPCA => Smooth Ridge => SPCA_cov
Note that in RMSE, HOLP is slightly better than ridge, but on held-out, holp is terrible.

###PM
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_pms8090_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)
res4 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep5_pm_dcv_pms90_smooth_shrink.csv")
res4 <-  cbind(res4, matrix(data=NA, nrow=nrow(res4), ncol = (length(res) - length(res4))))
colnames(res4) <- colnames(res)

# Define custom color palette
custom_colors <- c(
  "PCA 90" = "#E41A1C",        # Red
  "SPCA 90" = "#377EB8",       # Blue
  "Ridge" = "#4DAF4A",         # Green
  "Smooth_PCA 90" = "#984EA3", # Purple
  "Smooth_SPCA 90" = "#FF7F00",# Orange
  "Smooth_Ridge" = "#FFFF33",  # Yellow
  "PMS" = "#A65628",           # Brown
  "PMS_holp" = "#F781BF",      # Pink
  "SmoothPCA_Proj" = "#8DD3C7",  # Light teal
  "SmoothSPCA_Proj" = "#B3DE69", # Light green
  "SmoothPCA_Cov" = "#FDB462",   # Orange-yellow
  "SmoothSPCA_Cov" = "#FB8072"   # Salmon pink
)

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),], res3[1:2, ], res4[1:4, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[3:4, ], res4[5:8, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Somehow all 4 cov and proj have terrible test RMSE, especially against other methods. 

//sep7 pm with shrink = 0.01 10294259 ...  ==> also added correlation
//sep7 age with shrink = 0.01 10294252 ==> also added correlation

I should try with corr


Simulation debug
10295227 ==> this shows that for a PCA method, with this def of simulation. Signal stength of 2 yields 2 PCs, and strength of 3 yields 1 PC (which breaks the algo)

//`sim_gaussmask_sens3.R`     10358609
//`sim_dbmask_sens3.R`        10358612
//`sim_binmask_sens3.R`       10358616
//`sim_sparsemask_sens3.R`    10358660
[failed] `sim_SPCAmask_sens3.R`      10358742 => said "cannot allocate vector of size 4346675.7 Gb" ?? 



#8 Sep

##Re-run of real-data with shrinkage
sep7, smaller shrink (0.01) and added correlation
###Age
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)
res4 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep7_age_dcv_pms90_smooth_shrink.csv")
res4 <-  cbind(res4, matrix(data=NA, nrow=nrow(res4), ncol = (length(res) - length(res4))))
colnames(res4) <- colnames(res)

# Define custom color palette
custom_colors <- c(
  "PCA 90" = "#E41A1C",        # Red
  "SPCA 90" = "#377EB8",       # Blue
  "Ridge" = "#4DAF4A",         # Green
  "Smooth_PCA 90" = "#984EA3", # Purple
  "Smooth_SPCA 90" = "#FF7F00",# Orange
  "Smooth_Ridge" = "#FFFF33",  # Yellow
  "PMS" = "#A65628",           # Brown
  "PMS_holp" = "#F781BF",      # Pink
  "SmoothPCA_Proj" = "#8DD3C7",  # Light teal
  "SmoothSPCA_Proj" = "#B3DE69", # Light green
  "SmoothPCA_Cov" = "#FDB462",   # Orange-yellow
  "SmoothSPCA_Cov" = "#FB8072",   # Salmon pink
  "SmoothPCA_Corr" = "#66C2A5",  # Medium teal
  "SmoothSPCA_Corr" = "#FC8D62"  # Dark salmon/orange
)

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),], res3[1:2, ], res4[1:6, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[3:4, ], res4[7:12, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Ranking is still exact same, so ridge - spca - smooth ridge - smooth spca

###Age
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_pms8090_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)
res4 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep7pmdcv_pms90_smooth_shrink.csv")
res4 <-  cbind(res4, matrix(data=NA, nrow=nrow(res4), ncol = (length(res) - length(res4))))
colnames(res4) <- colnames(res)

# Define custom color palette
custom_colors <- c(
  "PCA 90" = "#E41A1C",        # Red
  "SPCA 90" = "#377EB8",       # Blue
  "Ridge" = "#4DAF4A",         # Green
  "Smooth_PCA 90" = "#984EA3", # Purple
  "Smooth_SPCA 90" = "#FF7F00",# Orange
  "Smooth_Ridge" = "#FFFF33",  # Yellow
  "PMS" = "#A65628",           # Brown
  "PMS_holp" = "#F781BF",      # Pink
  "SmoothPCA_Proj" = "#8DD3C7",  # Light teal
  "SmoothSPCA_Proj" = "#B3DE69", # Light green
  "SmoothPCA_Cov" = "#FDB462",   # Orange-yellow
  "SmoothSPCA_Cov" = "#FB8072",   # Salmon pink
  "SmoothPCA_Corr" = "#66C2A5",  # Medium teal
  "SmoothSPCA_Corr" = "#FC8D62"  # Dark salmon/orange
)

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),], res3[1:2, ], res4[1:6, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[3:4, ], res4[7:12, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
The Everything is the same, corr is very bad



##Simulation
```{r}
accuracy_cal <- function(rank.vec, mask.signal) {
  # Determine the number of top indices to consider
  n <- length(mask.signal)
  
  # Take the top n indices from rank.vec
  top_n <- rank.vec[1:n]
    
  # Compute True Positives (TP)
  TP <- length(intersect(top_n, mask.signal))
  
  # Compute Overlap as the percentage of true positives
  overlap <- round(TP * 100 / n, 3)
  
  # Compute False Positives (FP)
  FP <- length(setdiff(top_n, mask.signal))
  
  # Compute False Negatives (FN)
  FN <- length(setdiff(mask.signal, top_n))
  
  # Compute False Positive Rate (FPR)
  total_non_signal <- length(rank.vec) - n
  FPR <- round(FP*100 / total_non_signal, 3)
  
  # Compute False Discovery Rate (FDR)
  FDR <- round(FP*100 / (FP + TP), 3)
  
  # Return the results as a named list
  return(list(
    overlap = overlap,
    FPR = FPR,
    FDR = FDR
  ))
}
```

```{r}
# Define the parameters
signal_types <- c("binmask", "dbmask","gaussmask", "sparsemask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
signal_strengths <- c(0,0.1,0.3,0.5)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep5_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }

      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask" || a == "SPCAcoefmask" ) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs Signal Strength -", signal_type),
         x = "Signal Strength",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```


#19 Sep

Major system update., followed this guideline for the new R
I went through a painstaking process of manually installing packages, dependcies and dependencies of dependencies

All sep10
//`sim_binmask_sens4.R`   12138440    
//`sim_gaussmask_sens4.R` 12138513
//`sim_dbmask_sens4.R`    12138492    
//`sim_sparsemask_sens4.R`12138487    
//`sim_SPCAmask_sens4.R`  12138510    

real data with shrink = 0 (HOLP)
//sep16_age_dcv_pms90_smooth_shrink 12138554

Also created:, for running ridge and lasso on real data
//`age_ridgelasso.R` sep19_age 12138998
//`pm_ridgelasso.R` sep19_pm 12139000


#20 Sep


##Simulation
Plotting simulation again. Now with building constrained SNR 


```{r}
# Define the parameters
signal_types <- c("binmask", "dbmask","gaussmask", "sparsemask","SPCAmask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep10_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  
  ####errors on gaussmak, sep10500 instread of sep10_500
  if(a == "gaussmask"){
    base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep10500_"
  } else {
    base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep10_500_"
  }
  ########
  
  for (b in methods) {
    for (c in rsquares) {
      # Determine (d) based on the method
      if (grepl("_smooth$", b)) {
        d <- "3_"
      } else {
        d <- ""
      }

      # Construct the file path
      file_path <- paste0(base_path, a, "_", d, "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask" || a == "SPCAcoefmask" ) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs R-square -", signal_type),
         x = "R-square",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
It appears, via visualisation that only Ridge, tmap, SPCA, SPCA smooth (viz looks funny, lines) follow the correct ordering. HOLP, PMS and SPCA smooth proj SHOULD have good results but ordering is revserse somehow.

Note: note currently plotted here, but Ridge smooth is even better than ridge 

ACTUALLY, I think that PCA tries to look at variability, but perhaps with unif(0,0.1), the var is lower compared to the outside brain, let's try one with more var

FPR
```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = FPR, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,15) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("FPR vs R-square -", signal_type),
         x = "R-square",
         y = "FPR",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```

##Real data with artificial HOLP
Shrinkage = 0 (ie HOLP)
###Age
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)
res4 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep16_age_dcv_pms90_smooth_shrink.csv")
res4 <-  cbind(res4, matrix(data=NA, nrow=nrow(res4), ncol = (length(res) - length(res4))))
colnames(res4) <- colnames(res)

# Define custom color palette
custom_colors <- c(
  "PCA 90" = "#E41A1C",        # Red
  "SPCA 90" = "#377EB8",       # Blue
  "Ridge" = "#4DAF4A",         # Green
  "Smooth_PCA 90" = "#984EA3", # Purple
  "Smooth_SPCA 90" = "#FF7F00",# Orange
  "Smooth_Ridge" = "#FFFF33",  # Yellow
  "PMS" = "#A65628",           # Brown
  "PMS_holp" = "#F781BF",      # Pink
  "SmoothPCA_Proj" = "#8DD3C7",  # Light teal
  "SmoothSPCA_Proj" = "#B3DE69", # Light green
  "SmoothPCA_Cov" = "#FDB462",   # Orange-yellow
  "SmoothSPCA_Cov" = "#FB8072",   # Salmon pink
  "SmoothPCA_Corr" = "#66C2A5",  # Medium teal
  "SmoothSPCA_Corr" = "#FC8D62"  # Dark salmon/orange
)

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),], res3[1:2, ], res4[1:6, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[3:4, ], res4[7:12, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Shrinkage differs from HOLP because of Smoothing!!

Also load ridge and lasso 
####age
```{r}
#lasso
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/pms2/pile/sep19_age_lasso_noscale_",i,".csv"))))
}
(l.train <- quantile(hs.int[,5],c(0.5)))
(l.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/pms2/pile/sep19_age_ridge_noscale_",i,".csv"))))
}
(r.train <- quantile(hs.int[,5],c(0.5)))
(r.test <-quantile(hs.int[,6],c(0.5)))
```

####pm
```{r}
#lasso
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/pms2/pile/sep19_pm_lasso_noscale_",i,".csv"))))
}
(l.train <- quantile(hs.int[,5],c(0.5)))
(l.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/pms2/pile/sep19_pm_ridge_noscale_",i,".csv"))))
}
(r.train <- quantile(hs.int[,5],c(0.5)))
(r.test <-quantile(hs.int[,6],c(0.5)))
```
```{r}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))
train.test.ind <- list()
train.test.ind$test <- read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_test_index.csv')$x
train.test.ind$train <-  read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x
```
###Age
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_age_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)
res4 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep7_age_dcv_pms90_smooth_shrink.csv")
res4 <-  cbind(res4, matrix(data=NA, nrow=nrow(res4), ncol = (length(res) - length(res4))))
colnames(res4) <- colnames(res)

# Define custom color palette
custom_colors <- c(
  "PCA 90" = "#E41A1C",        # Red
  "SPCA 90" = "#377EB8",       # Blue
  "Ridge" = "#4DAF4A",         # Green
  "Smooth_PCA 90" = "#984EA3", # Purple
  "Smooth_SPCA 90" = "#FF7F00",# Orange
  "Smooth_Ridge" = "#FFFF33",  # Yellow
  "PMS" = "#A65628",           # Brown
  "PMS_holp" = "#F781BF",      # Pink
  "SmoothPCA_Proj" = "#8DD3C7",  # Light teal
  "SmoothSPCA_Proj" = "#B3DE69", # Light green
  "SmoothPCA_Cov" = "#FDB462",   # Orange-yellow
  "SmoothSPCA_Cov" = "#FB8072",   # Salmon pink
  "SmoothPCA_Corr" = "#66C2A5",  # Medium teal
  "SmoothSPCA_Corr" = "#FC8D62"  # Dark salmon/orange
)

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),], res3[1:2, ], res4[1:6, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  geom_hline(aes(yintercept = 0.9114, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$age[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[3:4, ], res4[7:12, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  geom_hline(aes(yintercept = 4.4875, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$age[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```
Ranking is still exact same, so ridge - spca - smooth ridge - smooth spca

###pm
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_pms8090_full.csv")
res2 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_pms8090_full_smooth.csv")
res2 <-  cbind(res2, matrix(data=NA, nrow=nrow(res2), ncol = (length(res) - length(res2))))
colnames(res2) <- colnames(res)
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/aug30_pm_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)
res4 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep7pmdcv_pms90_smooth_shrink.csv")
res4 <-  cbind(res4, matrix(data=NA, nrow=nrow(res4), ncol = (length(res) - length(res4))))
colnames(res4) <- colnames(res)

# Define custom color palette
custom_colors <- c(
  "PCA 90" = "#E41A1C",        # Red
  "SPCA 90" = "#377EB8",       # Blue
  "Ridge" = "#4DAF4A",         # Green
  "Smooth_PCA 90" = "#984EA3", # Purple
  "Smooth_SPCA 90" = "#FF7F00",# Orange
  "Smooth_Ridge" = "#FFFF33",  # Yellow
  "PMS" = "#A65628",           # Brown
  "PMS_holp" = "#F781BF",      # Pink
  "SmoothPCA_Proj" = "#8DD3C7",  # Light teal
  "SmoothSPCA_Proj" = "#B3DE69", # Light green
  "SmoothPCA_Cov" = "#FDB462",   # Orange-yellow
  "SmoothSPCA_Cov" = "#FB8072",   # Salmon pink
  "SmoothPCA_Corr" = "#66C2A5",  # Medium teal
  "SmoothSPCA_Corr" = "#FC8D62"  # Dark salmon/orange
)

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res2[c(1:3),], res3[1:2, ], res4[1:6, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  geom_hline(aes(yintercept = 0.9997, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res2[c(4:6),], res3[3:4, ], res4[7:12, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge', 'Smooth_PCA 90','Smooth_SPCA 90','Smooth_Ridge','PMS','PMS_holp'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  geom_hline(aes(yintercept = 1.0639, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

For pm with co.dat, I need to regress it out I suppose during the screening as well. 
In fact, let's keep it simple for now. Let's just include co.dat for prediction
`sep 20`
//`co_pm_pms_full_shrink.R` 12476111
//`co_pm_pms_full_raw_pms.R` 12476372

## Simulation

//`sim_binmask_sens4_reverse.R` sep20_test 12322226 ==> this is just to test having the order reverse, since some methods seem to have the order reversed.
//`sim_binmask_sens4_reverse_pms.R` 12337426 ==> fixing the pms

For all recent viz of that period, I move it to folder sep10

I think current results is bad (for pca and spca) due to low var in unif(), for PMS and holp, they are good when number of selected param is like 5k?
I will change binmask from runif 0.1 (var = 1/1200) to runif 6 (var = 3)

Running
//sep20 12361082

Also for only 100 predictions, I have created `sim_binmask_v.R`
//sep20_v100 12361220


#21 Sep
##Assessing the result of runif(6)
```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(PMS)
# Define the parameters
signal_types <- c("binmask","dbmask","gaussmask", "sparsemask","SPCAmask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep20_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {

  ########
  
  for (b in methods) {
    for (c in rsquares) {
      # Determine (d) based on the method

      # Construct the file path
      file_path <- paste0(base_path, a, "_", "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask" || a == "SPCAcoefmask" ) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs R-square -", signal_type),
         x = "R-square",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```

As expected.
FPR
```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = FPR, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,15) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("FPR vs R-square -", signal_type),
         x = "R-square",
         y = "FPR",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```


I will start running other sim

//`sim_gaussmask_sens4.R`   12485618
//`sim_dbmask_sens4.R`      12485718
//`sim_sparsemask_sens4.R`  12485819  
//`sim_SPCAmask_sens4.R`    12485775 

Created `sim_binmask_vn.R` for assessing variable 100, n varying from 100 to 500
//sep21_v100_n... 12482009

###pm
I just realised that I miss smooth PCA smooth SPCA
```{r}
library(feather)
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))
train.test.ind <- list()
train.test.ind$test <- read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_test_index.csv')$x
train.test.ind$train <-  read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x
```
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep20_pm_dcv_pms8090_full.csv")
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep20_pm_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)
res4 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep20_pm_dcv_pms90_smooth_shrink.csv")
res4 <-  cbind(res4, matrix(data=NA, nrow=nrow(res4), ncol = (length(res) - length(res4))))
colnames(res4) <- colnames(res)

# Define custom color palette
custom_colors <- c(
  "PCA 90" = "#E41A1C",        # Red
  "SPCA 90" = "#377EB8",       # Blue
  "Ridge" = "#4DAF4A",         # Green
  # "Smooth_PCA 90" = "#984EA3", # Purple
  # "Smooth_SPCA 90" = "#FF7F00",# Orange
  "Smooth_Ridge" = "#FFFF33",  # Yellow
  "PMS" = "#A65628",           # Brown
  "PMS_holp" = "#F781BF",      # Pink
  "SmoothPCA_Proj" = "#8DD3C7",  # Light teal
  "SmoothSPCA_Proj" = "#B3DE69", # Light green
  "SmoothPCA_Cov" = "#FDB462",   # Orange-yellow
  "SmoothSPCA_Cov" = "#FB8072",   # Salmon pink
  "SmoothPCA_Corr" = "#66C2A5",  # Medium teal
  "SmoothSPCA_Corr" = "#FC8D62"  # Dark salmon/orange
)

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res3[1:2, ], res4[1:7, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge','PMS','PMS_holp','Smooth_Ridge'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  geom_hline(aes(yintercept = 0.9997, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res3[3:4, ], res4[8:14, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge','PMS','PMS_holp','Smooth_Ridge'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov', "SmoothPCA_Corr", "SmoothSPCA_Corr")

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  geom_hline(aes(yintercept = 1.0639, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

I think co.dat is not helping because of categorical variables. Let's keep it continuous variable
`sep21_pm`
// 12870731 ==> removing omeg and correlation as well to prevent oom
//12615441
```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Read data
res <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep21_pm_dcv_pms8090_full.csv")
res3 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep21_pm_dcv_nbpms_full.csv")
res3 <-  cbind(res3, matrix(data=NA, nrow=nrow(res3), ncol = (length(res) - length(res3))))
colnames(res3) <- colnames(res)
res4 <- read.csv("/well/nichols/users/qcv214/pms2/pile/sep21_pm_dcv_pms90_smooth_shrink.csv")
res4 <-  cbind(res4, matrix(data=NA, nrow=nrow(res4), ncol = (length(res) - length(res4))))
colnames(res4) <- colnames(res)

# Define custom color palette
custom_colors <- c(
  "PCA 90" = "#E41A1C",        # Red
  "SPCA 90" = "#377EB8",       # Blue
  "Ridge" = "#4DAF4A",         # Green
  "Smooth_PCA" = "#984EA3", # Purple
  "Smooth_SPCA" = "#FF7F00",# Orange
  "Smooth_Ridge" = "#FFFF33",  # Yellow
  "PMS" = "#A65628",           # Brown
  "PMS_holp" = "#F781BF",      # Pink
  "SmoothPCA_Proj" = "#8DD3C7",  # Light teal
  "SmoothSPCA_Proj" = "#B3DE69", # Light green
  "SmoothPCA_Cov" = "#FDB462",   # Orange-yellow
  "SmoothSPCA_Cov" = "#FB8072"   # Salmon pink
  # "SmoothPCA_Corr" = "#66C2A5",  # Medium teal
  # "SmoothSPCA_Corr" = "#FC8D62"  # Dark salmon/orange
)

# First plot
resdat <- as.data.frame(rbind(res[1:3,], res3[1:2, ], res4[1:7, ]))
num.vox.vec <- (1:50)*200
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge','PMS','PMS_holp','Smooth_Ridge','Smooth_PCA','Smooth_SPCA'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the first line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  geom_hline(aes(yintercept = 0.9997, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Train RMSE", x = "No. Variables", y = "RMSE", color = "Method")

# Second plot
resdat <- as.data.frame(rbind(res[4:6,], res3[3:4, ], res4[8:14, ]))
colnames(resdat) <- num.vox.vec
resdat$row_id <- c('PCA 90','SPCA 90','Ridge','PMS','PMS_holp','Smooth_Ridge','Smooth_PCA','Smooth_SPCA'
                   ,'SmoothPCA_Proj','SmoothSPCA_Proj','SmoothPCA_Cov','SmoothSPCA_Cov')

# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")

# Create the second line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line(size = 1) +
  geom_hline(aes(yintercept = 1.0639, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 10000, 1000)) +
  scale_color_manual(values = custom_colors) +
  labs(title = "Test RMSE", x = "No. Variables", y = "RMSE", color = "Method")
```

##loading v100_n
Perhaps fix R^2 = 0.9

Vary the n below to match n
```{r}
accuracy_cal_n <- function(rank.vec,num.subject, mask.signal) {
  # Determine the number of top indices to consider
  n <- length(mask.signal)
  
  # Take the top n indices from rank.vec
  top_n <- rank.vec[1:num.subject]
    
  # Compute True Positives (TP)
  TP <- length(intersect(top_n, mask.signal))
  
  # Compute Overlap as the percentage of true positives
  overlap <- round(TP * 100 / n, 3)
  
  # Return the results as a named list
  return(overlap)
}
```

True v is 100, n goes from 100 to 500

```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(PMS)
# Define the parameters
sample.size <- (1:5)*100

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)

base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep21_v100_n" 

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in sample.size) {
  ########
  for (b in methods) {
    for (c in rsquares) {
      # Construct the file path
      file_path <- paste0(base_path, a, "_500_binmask_", "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      mask.index <- (mask.vec %in% c(4, 15))
      mask.signal <- which(mask.index)[1:100]

      # Compute accuracy metrics
      metrics <- accuracy_cal_n(rank.vec = rank.vec,num.subject = a , mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SampleSize = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_strengths <- unique(results$SignalStrength)
# sample_sizes <- unique(results$SampleSize)
# Loop through each SignalType and create a separate plot
for (signal_strength in signal_strengths) {
  # Filter the results for the current SignalType
  # signal_data <- subset(results, SampleSize == sample_sizes)
  signal_data <- subset(results, SignalStrength == signal_strength)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SampleSize, y = Overlap, color = Method)) +
    geom_line(size = 1) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs No. Samples - R^2 = ", signal_strength),
         x = "No. Samples",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
The smooth cov and proj are the best. Ridge, SPCA90, MUA and pms don't perform well.
This increase in power could come from including number of params and not number of subjects alone, let's try another one with fixing number of param in submodel


True v is 100, n goes from 100 to 500

```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(PMS)
# Define the parameters
sample.size <- (1:5)*100

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)

base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep21_v100_n" 

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in sample.size) {
  ########
  for (b in methods) {
    for (c in rsquares) {
      # Construct the file path
      file_path <- paste0(base_path, a, "_500_binmask_", "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      mask.index <- (mask.vec %in% c(4, 15))
      mask.signal <- which(mask.index)[1:100]

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SampleSize = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_strengths <- unique(results$SignalStrength)
# sample_sizes <- unique(results$SampleSize)
# Loop through each SignalType and create a separate plot
for (signal_strength in signal_strengths) {
  # Filter the results for the current SignalType
  # signal_data <- subset(results, SampleSize == sample_sizes)
  signal_data <- subset(results, SignalStrength == signal_strength)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SampleSize, y = Overlap, color = Method)) +
    geom_line(size = 1) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs No. Samples - R^2 = ", signal_strength),
         x = "No. Samples",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
 Ridge, SPCA90, MUA and pms don't perform well again, but HOLP is best now, followed by PCA90


#24 sep
Correcting simulation run => adjust the correct variance 
//`sim_gaussmask_sens4.R`   13108383
//`sim_dbmask_sens4.R`      13108388
//`sim_sparsemask_sens4.R`  13108964  
//`sim_SPCAmask_sens4.R`     13108968


##Another simulation measure
WE can count how many and plot a bar chart, how many variables to include until the variable screening model discover all signals.
In SIS paper, this should be random (im guessing the signal) computed over 500 random runs and plot distribution.
For our case, we could run it 500 times with data being random?

new function
```{r}
find_shortest_subarray_length <- function(rank.vec, mask.signal) {
  # Initialize an empty set to track found elements from mask.signal
  found_signals <- integer(0)
  # Iterate over rank.vec to find the shortest subarray
  for (i in seq_along(rank.vec)) {
    # If the current element in rank.vec is part of mask.signal, add it to found_signals
    if (rank.vec[i] %in% mask.signal) {
      found_signals <- unique(c(found_signals, rank.vec[i]))
    }
    # Check if all elements of mask.signal are found
    if (length(found_signals) == length(mask.signal)) {
      return(i)  # Return the index, which represents the length of the subarray
    }
  }
  # If the loop completes without finding all elements, return NA or a message
  return(NA)  # This means not all elements of mask.signal were found
}
```

```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(PMS)
# Define the parameters
signal_types <- c("binmask","dbmask","gaussmask", "sparsemask","SPCAmask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep20_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {

  ########
  
  for (b in methods) {
    for (c in rsquares) {
      # Determine (d) based on the method

      # Construct the file path
      file_path <- paste0(base_path, a, "_", "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask" || a == "SPCAcoefmask" ) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- find_shortest_subarray_length(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        NumSub = metrics
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs R-square -", signal_type),
         x = "R-square",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
```{r}
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the barplot with a horizontal line at y = 15847
  p <- ggplot(signal_data, aes(x = as.factor(SignalStrength), y = NumSub, fill = Method)) +
    geom_bar(stat = "identity", position = "dodge", color = "black") +  # Barplot with distinct groups
    geom_hline(aes(yintercept = 15847, color = "Max Predictors"), linetype = "dashed", size = 1) +  # Add horizontal line
    scale_fill_manual(values = custom_colors) +  # Use custom fill colors
    scale_color_manual(name = "Reference Line", values = c("Max Predictors" = "red")) +  # Add color for the line in legend
    theme_minimal() +
    labs(title = paste("Number of Subarray Lengths vs R-square -", signal_type),
         x = "R-square",
         y = "Number of Subarray Lengths",
         fill = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    ) +
    guides(color = guide_legend(override.aes = list(linetype = "dashed")))  # Adjust the legend for the line
  
  # Display the plot
  print(p)
}
```
So in terms of separting meaningful and non-meaningful. These methods apart from HOLP are terrible. Maybe due to smoothing or structural dependency??

```{r}
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Define the number of true predictors for each signal type
true_predictors <- c("binmask" = 1867, "dbmask" = 1718, "gaussmask" = 1867, "sparsemask" = 1585, "SPCAmask" = 1600)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Extract the true predictor value for the current signal type
  true_predictor_value <- true_predictors[signal_type]
  
  # Create the barplot with horizontal lines
  p <- ggplot(signal_data, aes(x = as.factor(SignalStrength), y = NumSub, fill = Method)) +
    geom_bar(stat = "identity", position = "dodge", color = "black") +  # Barplot with distinct groups
    
    # Add horizontal line for Max Predictors (15847)
    geom_hline(aes(yintercept = 15847, color = "Max Predictors"), linetype = "dashed", size = 1) +
    
    # Add horizontal line for True Predictors (based on signal_type)
    geom_hline(aes(yintercept = true_predictor_value, color = "True Predictors"), linetype = "dotted", size = 1) +
    
    scale_fill_manual(values = custom_colors) +  # Use custom fill colors
    scale_color_manual(name = "Reference Lines", values = c("Max Predictors" = "red", "True Predictors" = "blue")) +  # Add color for the lines in the legend
    theme_minimal() +
    labs(title = paste("Number of Subarray Lengths vs R-square -", signal_type),
         x = "R-square",
         y = "Number of Subarray Lengths",
         fill = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    ) +
    
    # Adjust the legend for the reference lines
    guides(color = guide_legend(override.aes = list(linetype = c("dashed", "dotted"))))
  
  # Display the plot
  print(p)
}
```

##Viz for real data pm
I created `/well/nichols/users/qcv214/pms2/viz/sep21_real` which include all co_pm (but co shouldnt matter) viz

let's look at summary of smooth ridge since it's too good
```{r}
sm.ridge <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sep24_pm_dcv_smooth_ridge.nii.gz','/well/nichols/users/qcv214/bnn2/res3/res3mask.nii.gz'))
summary(sm.ridge)
```
All coef are effectively 0. Does smooth ridge just use co.dat to predict pm?
I can check it here since it's small
### Fitting ridge on co.dat data
```{r}
library(feather)
library(glmnet)
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))
train.test.ind <- list()
train.test.ind$test <- read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_test_index.csv')$x
train.test.ind$train <-  read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x
age <- as.numeric(age_tab$age)
sex <-  as.numeric(age_tab$sex)
sex <- sapply(sex, function(x) replace(x, x==0,-1)) #Change female to -1, male to 1
depind <- age_tab$DepInd
co.dat <- cbind(sex,depind,age)
#response 
pm_tf <- age_tab$pm_tf

mod.ridge <-  cv.glmnet(co.dat[train.test.ind$train, ],pm_tf[train.test.ind$train], alpha=0)  #fixing lambda
  beta <- coef(mod.ridge, s = "lambda.min")
  rmse.train <- sqrt(mean((as.numeric(pm_tf[train.test.ind$train] - cbind(1,co.dat[train.test.ind$train, ])%*%beta))^2))
  rmse.test <- sqrt(mean((as.numeric(pm_tf[train.test.ind$test] - cbind(1,co.dat[train.test.ind$test, ])%*%beta))^2))
```
train 0.96 and test 1.03 ==> these are actually better than all imaging

##Notes
I have noticed that smooth PCA is wrong in co.pm => corrected.
Also added rank-based PMS.
`sep24` 
raw  13628967
shrink 13628921

creating `sep24_real/` to store the viz

#25 Sep
Created `gen_age_HOLP_binmask.R` to get realisation of running HOLP on age on Bin mask. Obtaining beta via brain viz and MSE
//13641246

##load this data
```{r}
res <- read.csv('/well/nichols/users/qcv214/pms2/pile/sep25_age_HOLP_binmask_fit.csv')
res
```
from here, inside signal area, Unif(0,0.8) or unif (1) isn't a bad estimate
The `'/well/nichols/users/qcv214/pms2/viz/sep25_age_HOLP_binmask_fit'` is the mask
```{r}
library(PMS)
library(oro.nifti)

mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
#Defining signal to be around region 4 and 15 
mask.index <- (mask.vec %in% c(4,15))
mask.signal <- which(mask.index) #

beta.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sep25_age_HOLP_binmask_fit.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))[mask.signal]
summary(beta.vec)
```

Visualising beta HOLP
```{r}
mask.temp <-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz')
mask.temp[mask.temp > 0][mask.index] <- beta.vec
mask.temp[mask.temp != 0][!mask.index] <- 0
mask.temp@datatype = 16
mask.temp@bitpix = 32
writeNIfTI(mask.temp,paste0('/well/nichols/users/qcv214/pms2/viz/sep25_age_HOLP_binmask_fit_viz'))
```


#26 sep

## sanity check
create `sim_binmask_sens4_test1.R` (sep26_test) to check if {beta = 1, unif(0.1) is equivalent to beta = 1/60, unif(6)}
//13628833
###Assessing the result of runif(6) beta = 1/60
```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(PMS)
# Define the parameters
signal_types <- c("binmask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep26_test_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {

  ########
  
  for (b in methods) {
    for (c in rsquares) {
      # Determine (d) based on the method

      # Construct the file path
      file_path <- paste0(base_path, a, "_", "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask" || a == "SPCAcoefmask" ) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs R-square -", signal_type),
         x = "R-square",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
It's not the same as runif(1) but same as runif(6)

###Assessing the result of runif(6) beta = 1/60
```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(PMS)
# Define the parameters
signal_types <- c("binmask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep20_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {

  ########
  
  for (b in methods) {
    for (c in rsquares) {
      # Determine (d) based on the method

      # Construct the file path
      file_path <- paste0(base_path, a, "_", "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask" || a == "SPCAcoefmask" ) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs R-square -", signal_type),
         x = "R-square",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```

This is strange.


## Simulation with HOLP beta
with this set up, I can actually compute ||beta-true_beta||^2
created `sim_binmask_sen45` using unif(1) an beta realised from fitting HOLP.
//sep26_500 13641632 => no beta error yet.

```{r}
accuracy_cal <- function(rank.vec, mask.signal) {
  # Determine the number of top indices to consider
  n <- length(mask.signal)
  
  # Take the top n indices from rank.vec
  top_n <- rank.vec[1:n]
    
  # Compute True Positives (TP)
  TP <- length(intersect(top_n, mask.signal))
  
  # Compute Overlap as the percentage of true positives
  overlap <- round(TP * 100 / n, 3)
  
  # Compute False Positives (FP)
  FP <- length(setdiff(top_n, mask.signal))
  
  # Compute False Negatives (FN)
  FN <- length(setdiff(mask.signal, top_n))
  
  # Compute False Positive Rate (FPR)
  total_non_signal <- length(rank.vec) - n
  FPR <- round(FP*100 / total_non_signal, 3)
  
  # Compute False Discovery Rate (FDR)
  FDR <- round(FP*100 / (FP + TP), 3)
  
  # Return the results as a named list
  return(list(
    overlap = overlap,
    FPR = FPR,
    FDR = FDR
  ))
}
```

```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(PMS)
# Define the parameters
signal_types <- c("binmask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/sep26_500_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {

  ########
  
  for (b in methods) {
    for (c in rsquares) {
      # Determine (d) based on the method

      # Construct the file path
      file_path <- paste0(base_path, a, "_", "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "dbmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 19))
        mask.signal <- which(mask.index)
      } else if (a == "gaussmask") {
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)
      } else if (a == "sparsemask") {
        mask.signal <- seq(1, length(rank.vec), 10) # Signal every 10th voxel
      } else if (a == "SPCAmask" || a == "SPCAcoefmask" ) {
        mask.rank <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/viz/sim/aug21_500_age_rank_SPCA90_smooth.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.signal <- order(mask.rank,decreasing = TRUE)[1:1600]
      }

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    # ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs R-square -", signal_type),
         x = "R-square",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
This plot is decent

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = FPR, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    # ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("FPR vs R-square -", signal_type),
         x = "R-square",
         y = "FPR",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```

Created
`sim_binmask_vn5.R` assessing v = 100 with n = 100,...,500 from true beta
//oct1_v100_n 14700420

#2 Oct
True v is 100, n goes from 100 to 500

```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(PMS)
# Define the parameters
sample.size <- (1:5)*100

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)

base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/oct1_v100_n" 

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in sample.size) {
  ########
  for (b in methods) {
    for (c in rsquares) {
      # Construct the file path
      file_path <- paste0(base_path, a, "_500_binmask_", "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      mask.index <- (mask.vec %in% c(4, 15))
      mask.signal <- which(mask.index)[1:100]

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SampleSize = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_strengths <- unique(results$SignalStrength)
# sample_sizes <- unique(results$SampleSize)
# Loop through each SignalType and create a separate plot
for (signal_strength in signal_strengths) {
  # Filter the results for the current SignalType
  # signal_data <- subset(results, SampleSize == sample_sizes)
  signal_data <- subset(results, SignalStrength == signal_strength)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SampleSize, y = Overlap, color = Method)) +
    geom_line(size = 1) +  # Make the lines bolder with size = 1.5
    ylim(0,70) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs No. Samples - R^2 = ", signal_strength),
         x = "No. Samples",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
oct2_v10_n   14778067 => v 10
```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(PMS)
# Define the parameters
sample.size <- (1:5)*100

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)

base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/oct2_v10_n" 

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in sample.size) {
  ########
  for (b in methods) {
    for (c in rsquares) {
      # Construct the file path
      file_path <- paste0(base_path, a, "_500_binmask_", "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      mask.index <- (mask.vec %in% c(4, 15))
      mask.signal <- which(mask.index)[1:10]

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SampleSize = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_strengths <- unique(results$SignalStrength)
# sample_sizes <- unique(results$SampleSize)
# Loop through each SignalType and create a separate plot
for (signal_strength in signal_strengths) {
  # Filter the results for the current SignalType
  # signal_data <- subset(results, SampleSize == sample_sizes)
  signal_data <- subset(results, SignalStrength == signal_strength)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SampleSize, y = Overlap, color = Method)) +
    geom_line(size = 1) +  # Make the lines bolder with size = 1.5
    ylim(0,70) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs No. Samples - R^2 = ", signal_strength),
         x = "No. Samples",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
I think 10 is too little


Running 
oct2_v300 14903630 ==> using  300 true effects and 300-1000 subjects



#3 Oct

##v= 300
```{r}
accuracy_cal <- function(rank.vec, mask.signal) {
  # Determine the number of top indices to consider
  n <- length(mask.signal)
  
  # Take the top n indices from rank.vec
  top_n <- rank.vec[1:n]
    
  # Compute True Positives (TP)
  TP <- length(intersect(top_n, mask.signal))
  
  # Compute Overlap as the percentage of true positives
  overlap <- round(TP * 100 / n, 3)
  
  # Compute False Positives (FP)
  FP <- length(setdiff(top_n, mask.signal))
  
  # Compute False Negatives (FN)
  FN <- length(setdiff(mask.signal, top_n))
  
  # Compute False Positive Rate (FPR)
  total_non_signal <- length(rank.vec) - n
  FPR <- round(FP*100 / total_non_signal, 3)
  
  # Compute False Discovery Rate (FDR)
  FDR <- round(FP*100 / (FP + TP), 3)
  
  # Return the results as a named list
  return(list(
    overlap = overlap,
    FPR = FPR,
    FDR = FDR
  ))
}
```
```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(PMS)
# Define the parameters
sample.size <- (3:10)*100

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)

base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/oct2_v300_n" 

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)

for (a in sample.size) {
  ########
  for (b in methods) {
    for (c in rsquares) {
      # Construct the file path
      file_path <- paste0(base_path, a, "_500_binmask_", "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      mask.index <- (mask.vec %in% c(4, 15))
      mask.signal <- which(mask.index)[1:300]

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SampleSize = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```
17 hours and still running

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_strengths <- unique(results$SignalStrength)
# sample_sizes <- unique(results$SampleSize)
# Loop through each SignalType and create a separate plot
for (signal_strength in signal_strengths) {
  # Filter the results for the current SignalType
  # signal_data <- subset(results, SampleSize == sample_sizes)
  signal_data <- subset(results, SignalStrength == signal_strength)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SampleSize, y = Overlap, color = Method)) +
    geom_line(size = 1) +  # Make the lines bolder with size = 1.5
    # ylim(0,70) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs No. Samples - R^2 = ", signal_strength),
         x = "No. Samples",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
From this, we can see that SPCA shrinkage outperform PCA  shrinkage, so maybe ignore pca shrinkage.

##Note
I am thinking whether I should start doing simulation set up similar to SIS paper
let u ~ Ber(0.4), z ~ N(0,1), a = 4log(n)/sqrt(n) then let beta = (-1)^u (a + |z|) => this is for s=8/1000 or 18/20,000 (5log(n)/sqrt(n)). The difficult thing is I want 2000
But do I really need this? HOLP fitted should be good enough.
- if i wanna assess multiple runs, then I can fix signal region and use this specification (on 300 regions)

I wanna assess stability

I think Stability and Consistency is so similar. Consistency is increasing n, stability is fixing n then change samples. technically they can be combined, but let's keep separated.

*actually I can create a simulation set up where I divide the signals into two separate chunks, or even scatter around

###To think about
Technically, I can fit holp on the whole sub brain image, then take the coefficients for different simulation studies. But that would make it very diverse.. I would have to re-run the whole set up again.
OR
I continue with this just use the centre of the brain that's been fitted HOLP already [let's go with this first ]



Oct 3, I changed it such that it doesn't use the full subbrain signal, only first 300. And increased number of subject to 1000 for training, and reduce number of evaluating voxels
`oct3_1000...`
//`sim_binmask_sens5.R`  15036904
//`sim_dbmask_sens5.R`. 15037157
//`sim_sparsemask_sens5.R`. 15036906
`sim_binmask_stab5.R`  oct3_stability_ 15046182 ==> i think using 500 subjects

##Look at simulation
```{r}
if (!require("pacman")) {install.packages("pacman");library(pacman)}
p_load(PMS)
# Define the parameters
signal_types <- c("binmask","dbmask", "sparsemask")

methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
rsquares <- c(1,0.5,0.9)
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/oct3_1000_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Overlap = numeric(),
  FPR = numeric(),
  FDR = numeric(),
  stringsAsFactors = FALSE
)
mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.index <- (mask.vec %in% c(4, 15))

for (a in signal_types) {

  ########
  
  for (b in methods) {
    for (c in rsquares) {
      # Determine (d) based on the method

      # Construct the file path
      file_path <- paste0(base_path, a, "_", "rank_str", c, "_", b, ".nii.gz")
      ####
      rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
      rank.vec <- order(rank.vec, decreasing = TRUE)
      # Define the mask.signal based on signal type
      if (a == "binmask") {
        mask.signal <- which(mask.index)[1:300]
      } else if (a == "dbmask") {
        mask.signal <- which(mask.index)[c(1:150, 1001:1150)]
      } else if (a == "sparsemask") {
        mask.signal <- which(mask.index)[seq(1,1500,5)]
      } 

      # Compute accuracy metrics
      metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Overlap = metrics$overlap,
        FPR = metrics$FPR,
        FDR = metrics$FDR
      ))
    }
  }
}
# Save the results as a CSV file
# write.csv(results, "/well/nichols/users/qcv214/pms2/viz/sim/sensitivity_results.csv", row.names = FALSE)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    # ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs R-square -", signal_type),
         x = "R-square",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
For bin mask, the results should be the same as having 1000 in the screening consistency, but results seem so different.

Testing `sim_binmask_sens6.R` ==> running sim multiple time and recording results right away.
//15104407

let me test it 
```{r}
results.bin <- read.csv('/well/nichols/users/qcv214/pms2/pile/sim_oct3_binmask.csv')
```
it works extremely well.
all oct3
`sim_binmask_sens6.R` 15130961
`sim_dbmask_sens6.R` 15132142
`sim_sparsemask_sens6.R` 15132461

#4 Oct

##look at stability
```{r}
library(PMS)
# Define the parameters
signal_types <- c("binmask")
methods <- c("PCA90", "SPCA90", "PCA90_smooth", "SPCA90_smooth", "ridge", "ridge_smooth", "pmshi", "holp","tmap",
             "PCA90_smooth_proj", "PCA90_smooth_cov","SPCA90_smooth_proj", "SPCA90_smooth_cov")
signal_strengths <- c(0.5,0.9,1)
sets <- 1:10 # Now handling 10 sets
base_path <- "/well/nichols/users/qcv214/pms2/viz/sim/oct3_stability_"

# Initialize a data frame to store the results
results <- data.frame(
  SignalType = character(),
  Method = character(),
  SignalStrength = numeric(),
  Metric = character(),
  SD = numeric(),
  stringsAsFactors = FALSE
)

for (a in signal_types) {
  for (b in methods) {
    for (c in signal_strengths) {
      
      # Initialize lists to store metrics for all 10 sets
      overlap_list <- numeric(length(sets))
      
      for (e in sets) {
        # Construct the file path for each set
        file_path <- paste0(base_path, a, "_rank_str", c, "_set", e, "_", b, ".nii.gz")
        
        # Load the rank vector
        rank.vec <- c(fast_read_imgs_mask(file_path, '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))

        # Define the mask.signal based on signal type
        mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz', '/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
        mask.index <- (mask.vec %in% c(4, 15))
        mask.signal <- which(mask.index)[1:300]

        # Compute accuracy metrics
        metrics <- accuracy_cal(rank.vec = rank.vec, mask.signal = mask.signal)

        # Store the metrics for each set
        overlap_list[e] <- metrics$overlap
      }
      
      # Compute the standard deviation of metrics across the 10 sets
      sd_overlap <- sd(overlap_list)
      
      # Store the results in the data frame
      results <- rbind(results, data.frame(
        SignalType = a,
        Method = b,
        SignalStrength = c,
        Metric = "Overlap",
        SD = sd_overlap
      ))

    }
  }
}
```
```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pmshi" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot for each metric
for (signal_type in signal_types) {
  for (metric in unique(results$Metric)) {
    # Filter the results for the current SignalType and Metric
    signal_data <- subset(results, SignalType == signal_type & Metric == metric)
    
    # Create the plot with bolder lines and distinct colors
    p <- ggplot(signal_data, aes(x = SignalStrength, y = SD, color = Method)) +
      geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
      scale_color_manual(values = custom_colors) +  # Use custom colors
      theme_minimal() +
      labs(title = paste(metric, "Standard Deviation vs R-square -", signal_type),
           x = "R-square",
           y = paste(metric, "Standard Deviation"),
           color = "Method") +
      theme(
        plot.title = element_text(size = 14, face = "bold"),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10)
      )
    
    # Display the plot
    print(p)
    
    # Save the plot to a file
    ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_", metric, "_stability_sd_plot.png"),
           plot = p, width = 8, height = 6)
  }
}
```
Perhaps this isn't really needed anymore. We can just use the results from the other main simulation study and observe sd. The number of subjects considered will be greater but should be okay.


##Look at the simulation results
```{r}
# Load necessary packages
if (!require("pacman")) {install.packages("pacman"); library(pacman)}
p_load(dplyr, readr)

# Define the signal types and the file path template
signal_types <- c("binmask", "dbmask", "sparsemask")
# signal_types <- c("binmask")
base_path <- "/well/nichols/users/qcv214/pms2/pile/sim_oct3_"

# Initialize an empty list to store the aggregated results for each signal_type
all_aggregated_results <- list()

# Loop through each signal_type
for (signal_type in signal_types) {
  # Load the CSV file
  file_path <- paste0(base_path, signal_type, ".csv")
  results <- read_csv(file_path)
  
  # Aggregate the results by Method and SignalStrength
  aggregated_results <- results %>%
    group_by(Method, SignalStrength) %>%
    summarise(
      Overlap_Median = median(Overlap, na.rm = TRUE),
      Overlap_SD = sd(Overlap, na.rm = TRUE),
      FPR_Median = median(FPR, na.rm = TRUE),
      FPR_SD = sd(FPR, na.rm = TRUE),
      FDR_Median = median(FDR, na.rm = TRUE),
      FDR_SD = sd(FDR, na.rm = TRUE)
    ) %>%
    mutate(SignalType = signal_type)  # Add SignalType column
  
  # Append to the list
  all_aggregated_results[[signal_type]] <- aggregated_results
}

# Concatenate all aggregated results into one matrix
results <- bind_rows(all_aggregated_results)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pms" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap_Median, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    # ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs R-square -", signal_type),
         x = "R-square",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
  # Save the plot to a file
  # ggsave(filename = paste0("/well/nichols/users/qcv214/pms2/viz/sim/", signal_type, "_sensitivity_plot.png"),
  #        plot = p, width = 8, height = 6)
}
```
```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pms" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_types <- unique(results$SignalType)

# Loop through each SignalType and create a separate plot
for (signal_type in signal_types) {
  # Filter the results for the current SignalType
  signal_data <- subset(results, SignalType == signal_type)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = SignalStrength, y = Overlap_SD, color = Method)) +
    geom_line(size = 1.5) +  # Make the lines bolder with size = 1.5
    # ylim(0,100) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs R-square -", signal_type),
         x = "R-square",
         y = "s.d. Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
}
```
`sim_binmask_vn6.R`. 15252317 (8,5,3) ==> running varying n with 10 different runs. ===> some runs can't load mmands
15255726 (1,7)


#5 Oct

##load screening consistency res
```{r}
# Load necessary packages
if (!require("pacman")) {install.packages("pacman"); library(pacman)}
p_load(dplyr, readr)


fnames <- paste0("/well/nichols/users/qcv214/pms2/pile/sim_oct4_v300n_binmask_iter",success.runs,".csv")
loaded.csv <- lapply(fnames, read.csv)
results <- do.call(rbind, loaded.csv)

# Initialize an empty list to store the aggregated results for each signal_type

  # Aggregate the results by Method and SignalStrength
aggregated_results <- results %>%
  group_by(Method, SignalStrength,sample_size) %>%
  summarise(
    Overlap_Median = median(Overlap, na.rm = TRUE),
    Overlap_SD = sd(Overlap, na.rm = TRUE),
    FPR_Median = median(FPR, na.rm = TRUE),
    FPR_SD = sd(FPR, na.rm = TRUE),
    FDR_Median = median(FDR, na.rm = TRUE),
    FDR_SD = sd(FDR, na.rm = TRUE),
    .groups = "drop"  # Remove grouping after summarise
  )
results <- aggregated_results

# Concatenate all aggregated results into one matrix
# results <- bind_rows(all_aggregated_results)

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pms" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_strengths <- unique(results$SignalStrength)
# sample_sizes <- unique(results$SampleSize)
# Loop through each SignalType and create a separate plot
for (signal_strength in signal_strengths) {
  # Filter the results for the current SignalType
  # signal_data <- subset(results, SampleSize == sample_sizes)
  signal_data <- subset(results, SignalStrength == signal_strength)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = sample_size, y = Overlap_Median, color = Method)) +
    geom_line(size = 1) +  # Make the lines bolder with size = 1.5
    # ylim(0,70) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs No. Samples - R^2 = ", signal_strength),
         x = "No. Samples",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
}
```
```{r}
# Load the ggplot2 library
library(ggplot2)

# Define a custom color palette with distinct colors
custom_colors <- c(
  "PCA90" = "#1b9e77",
  "SPCA90" = "#d95f02",
  "PCA90_smooth" = "#7570b3",
  "SPCA90_smooth" = "#e7298a",
  "ridge" = "#66a61e",
  "ridge_smooth" = "#77868e",
  "pms" = "#e6ab02",
  "holp" = "#a6761d",
  "tmap" = "#466791",
  "PCA90_smooth_proj" = "#8DD3C7",  # Light teal
  "PCA90_smooth_cov" = "#B3DE69", # Light green
  "SPCA90_smooth_proj" = "#FDB462",   # Orange-yellow
  "SPCA90_smooth_cov" = "#FB8072"   # Salmon pink
)

# Unique Signal Types
signal_strengths <- unique(results$SignalStrength)
# sample_sizes <- unique(results$SampleSize)
# Loop through each SignalType and create a separate plot
for (signal_strength in signal_strengths) {
  # Filter the results for the current SignalType
  # signal_data <- subset(results, SampleSize == sample_sizes)
  signal_data <- subset(results, SignalStrength == signal_strength)
  
  # Create the plot with bolder lines and distinct colors
  p <- ggplot(signal_data, aes(x = sample_size, y = Overlap_SD, color = Method)) +
    geom_line(size = 1) +  # Make the lines bolder with size = 1.5
    # ylim(0,70) +
    scale_color_manual(values = custom_colors) +  # Use custom colors
    theme_minimal() +
    labs(title = paste("Power vs No. Samples - R^2 = ", signal_strength),
         x = "No. Samples",
         y = "Power",
         color = "Method") +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10)
    )
  
  # Display the plot
  print(p)
}
```

`test_sparsePCA_size.R` 15747213 ==>observing the size of projection matrix

#6 Oct
##Saving simulation masks
I created `/well/nichols/users/qcv214/pms2/viz/sim/masks` to save masks

```{r}
library(PMS)
library(oro.nifti)

mask_subcor<-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask')
submask <-array(0,dim=dim(mask_subcor))
mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.index <- (mask.vec %in% c(4,15))
mask.signal <- which(mask.index)
submask[mask_subcor > 0] <- 1
submask[mask_subcor > 0][mask.signal] <- 2
writeNIfTI(submask,'/well/nichols/users/qcv214/pms2/viz/sim/masks/centre_mask') #/well/nichols/users/qcv214/pms2

##Get the sub Mask
mask_subcor<-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask')
submask <-array(0,dim=dim(mask_subcor))
mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.index <- (mask.vec %in% c(4,15))
mask.signal <- which(mask.index)[1:300]
submask[mask_subcor > 0] <- 1
submask[mask_subcor > 0][mask.signal] <- 2
writeNIfTI(submask,'/well/nichols/users/qcv214/pms2/viz/sim/masks/binmask_300') #/well/nichols/users/qcv214/pms2

#db mask
mask_subcor<-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask')
submask <-array(0,dim=dim(mask_subcor))
mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.index <- (mask.vec %in% c(4,15))
mask.signal <- which(mask.index)[c(1:150,1001:1150)]
submask[mask_subcor > 0] <- 1
submask[mask_subcor > 0][mask.signal] <- 2
writeNIfTI(submask,'/well/nichols/users/qcv214/pms2/viz/sim/masks/dbmask_300') #/well/nichols/users/qcv214/pms2

#sparse mask
mask_subcor<-oro.nifti::readNIfTI('/well/nichols/users/qcv214/pms2/sub150_centre_mask')
submask <-array(0,dim=dim(mask_subcor))
mask.vec <- c(fast_read_imgs_mask('/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz','/well/nichols/users/qcv214/pms2/sub150_centre_mask.nii.gz'))
mask.index <- (mask.vec %in% c(4,15))
mask.signal <- which(mask.index)[seq(1,1500,3)]
submask[mask_subcor > 0] <- 1
submask[mask_subcor > 0][mask.signal] <- 2
writeNIfTI(submask,'/well/nichols/users/qcv214/pms2/viz/sim/masks/sparsemask_300') #/well/nichols/users/qcv214/pms2
```


